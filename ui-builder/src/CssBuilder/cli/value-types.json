{
    "<identifier>": {
        "name": "<identifier>",
        "type": "type"
    },
    "<uri>": {
        "name": "<uri>",
        "prose": "URI values (Uniform Resource Identifiers, see [RFC3986], which includes URLs, URNs, etc) in this specification are denoted by <uri>. The functional notation used to designate URIs in property values is \"url()\", as in:",
        "type": "type"
    },
    "<margin-width>": {
        "name": "<margin-width>",
        "prose": "The properties defined in this section refer to the <margin-width> value type, which may take one of the following values:",
        "type": "type"
    },
    "<padding-width>": {
        "name": "<padding-width>",
        "prose": "The properties defined in this section refer to the <padding-width> value type, which may take one of the following values:",
        "type": "type",
        "values": [
            {
                "name": "<length>",
                "prose": "Specifies a fixed width.",
                "type": "value",
                "value": "<length>"
            },
            {
                "name": "<percentage>",
                "prose": "The percentage is calculated with respect to the width of the generated box’s containing block, even for padding-top and padding-bottom. If the containing block’s width depends on this element, then the resulting layout is undefined in CSS 2.",
                "type": "value",
                "value": "<percentage>"
            }
        ]
    },
    "<border-width>": {
        "name": "<border-width>",
        "prose": "The border width properties specify the width of the border area. The properties defined in this section refer to the <border-width> value type, which may take one of the following values:",
        "type": "type",
        "values": [
            {
                "name": "thin",
                "prose": "A thin border.",
                "type": "value",
                "value": "thin"
            },
            {
                "name": "medium",
                "prose": "A medium border.",
                "type": "value",
                "value": "medium"
            },
            {
                "name": "thick",
                "prose": "A thick border.",
                "type": "value",
                "value": "thick"
            },
            {
                "name": "<length>",
                "prose": "The border’s thickness has an explicit value. Explicit border widths cannot be negative.",
                "type": "value",
                "value": "<length>"
            }
        ]
    },
    "<border-style>": {
        "name": "<border-style>",
        "prose": "The border style properties specify the line style of a box’s border (solid, double, dashed, etc.). The properties defined in this section refer to the <border-style> value type, which may take one of the following values:",
        "type": "type",
        "values": [
            {
                "name": "none",
                "prose": "No border; the computed border width is zero.",
                "type": "value",
                "value": "none"
            },
            {
                "name": "hidden",
                "prose": "Same as none, except in terms of border conflict resolution for table elements.",
                "type": "value",
                "value": "hidden"
            },
            {
                "name": "dotted",
                "prose": "The border is a series of dots.",
                "type": "value",
                "value": "dotted"
            },
            {
                "name": "dashed",
                "prose": "The border is a series of short line segments.",
                "type": "value",
                "value": "dashed"
            },
            {
                "name": "solid",
                "prose": "The border is a single line segment.",
                "type": "value",
                "value": "solid"
            },
            {
                "name": "double",
                "prose": "The border is two solid lines. The sum of the two lines and the space between them equals the value of border-width.",
                "type": "value",
                "value": "double"
            },
            {
                "name": "groove",
                "prose": "The border looks as though it were carved into the canvas.",
                "type": "value",
                "value": "groove"
            },
            {
                "name": "ridge",
                "prose": "The opposite of groove: the border looks as though it were coming out of the canvas.",
                "type": "value",
                "value": "ridge"
            },
            {
                "name": "inset",
                "prose": "The border makes the box look as though it were embedded in the canvas.",
                "type": "value",
                "value": "inset"
            },
            {
                "name": "outset",
                "prose": "The opposite of inset: the border makes the box look as though it were coming out of the canvas.",
                "type": "value",
                "value": "outset"
            }
        ]
    },
    "<shape>": {
        "name": "<shape>",
        "prose": "In CSS 2, the only valid <shape> value is: rect(<top>, <right>, <bottom>, <left>) where <top> and <bottom> specify offsets from the top border edge of the box, and <right>, and <left> specify offsets from the left border edge of the box. Authors should separate offset values with commas. User agents must support separation with commas, but may also support separation without commas (but not a combination), because a previous revision of this specification was ambiguous in this respect. <top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box). When coordinates are rounded to pixel coordinates, care should be taken that no pixels remain visible when <left> and <right> have the same value (or <top> and <bottom> have the same value), and conversely that no pixels within the element’s border box remain hidden when these values are auto.",
        "type": "type"
    },
    "<top>": {
        "name": "<top>",
        "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
        "type": "type",
        "values": [
            {
                "name": "auto",
                "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
                "type": "value",
                "value": "auto"
            }
        ]
    },
    "<right>": {
        "name": "<right>",
        "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
        "type": "type",
        "values": [
            {
                "name": "auto",
                "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
                "type": "value",
                "value": "auto"
            }
        ]
    },
    "<bottom>": {
        "name": "<bottom>",
        "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
        "type": "type",
        "values": [
            {
                "name": "auto",
                "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
                "type": "value",
                "value": "auto"
            }
        ]
    },
    "<left>": {
        "name": "<left>",
        "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
        "type": "type",
        "values": [
            {
                "name": "auto",
                "prose": "<top>, <right>, <bottom>, and <left> may either have a <length> value or auto. Negative lengths are permitted. The value auto means that a given edge of the clipping region will be the same as the edge of the element’s generated border box (i.e., auto means the same as 0 for <top> and <left>, the same as the used value of the height plus the sum of vertical padding and border widths for <bottom>, and the same as the used value of the width plus the sum of the horizontal padding and border widths for <right>, such that four auto values result in the clipping region being the same as the element’s border box).",
                "type": "value",
                "value": "auto"
            }
        ]
    },
    "<absolute-size>": {
        "name": "<absolute-size>",
        "type": "type"
    },
    "<relative-size>": {
        "name": "<relative-size>",
        "type": "type"
    },
    "<points>": {
        "name": "<points>",
        "value": "[ <number>+ ]#",
        "type": "type"
    },
    "<dasharray>": {
        "name": "<dasharray>",
        "value": "[ [ <length-percentage> | <number> ]+ ]#",
        "type": "type"
    },
    "<marker-ref>": {
        "name": "<marker-ref>",
        "value": "<url>",
        "type": "type"
    },
    "<blend-mode>": {
        "name": "<blend-mode>",
        "type": "type",
        "value": "normal | multiply | screen | overlay | darken | lighten | color-dodge |color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
        "values": [
            {
                "name": "normal",
                "type": "value",
                "value": "normal"
            },
            {
                "name": "multiply",
                "type": "value",
                "value": "multiply"
            },
            {
                "name": "screen",
                "type": "value",
                "value": "screen"
            },
            {
                "name": "overlay",
                "type": "value",
                "value": "overlay"
            },
            {
                "name": "darken",
                "type": "value",
                "value": "darken"
            },
            {
                "name": "lighten",
                "type": "value",
                "value": "lighten"
            },
            {
                "name": "color-dodge",
                "type": "value",
                "value": "color-dodge"
            },
            {
                "name": "color-burn",
                "type": "value",
                "value": "color-burn"
            },
            {
                "name": "hard-light",
                "type": "value",
                "value": "hard-light"
            },
            {
                "name": "soft-light",
                "type": "value",
                "value": "soft-light"
            },
            {
                "name": "difference",
                "type": "value",
                "value": "difference"
            },
            {
                "name": "exclusion",
                "type": "value",
                "value": "exclusion"
            },
            {
                "name": "hue",
                "type": "value",
                "value": "hue"
            },
            {
                "name": "saturation",
                "type": "value",
                "value": "saturation"
            },
            {
                "name": "color",
                "type": "value",
                "value": "color"
            },
            {
                "name": "luminosity",
                "type": "value",
                "value": "luminosity"
            }
        ]
    },
    "<isolation-mode>": {
        "name": "<isolation-mode>",
        "type": "type",
        "value": "auto | isolate"
    },
    "<composite-mode>": {
        "name": "<composite-mode>",
        "type": "type",
        "value": "clear | copy | source-over | destination-over | source-in | destination-in | source-out | destination-out | source-atop | destination-atop | xor | lighter | plus-darker | plus-lighter"
    },
    "<self-position>": {
        "name": "<self-position>",
        "type": "type",
        "value": "center | start | end | self-start | self-end | flex-start | flex-end",
        "values": [
            {
                "name": "center",
                "prose": "Centers the alignment subject within its alignment container.",
                "type": "value",
                "value": "center"
            },
            {
                "name": "start",
                "prose": "Aligns the alignment subject to be flush with the alignment container’s start edge in the appropriate axis.",
                "type": "value",
                "value": "start"
            },
            {
                "name": "end",
                "prose": "Aligns the alignment subject to be flush with the alignment container’s end edge in the appropriate axis.",
                "type": "value",
                "value": "end"
            },
            {
                "name": "self-start",
                "prose": "Aligns the alignment subject to be flush with the edge of the alignment container corresponding to the alignment subject’s start side in the appropriate axis.",
                "type": "value",
                "value": "self-start"
            },
            {
                "name": "self-end",
                "prose": "Aligns the alignment subject to be flush with the edge of the alignment container corresponding to the alignment subject’s end side in the appropriate axis.",
                "type": "value",
                "value": "self-end"
            },
            {
                "name": "flex-start",
                "prose": "Only used in flex layout. [CSS-FLEXBOX-1] Aligns the alignment subject to be flush with the edge of the alignment container corresponding to the flex container’s main-start or cross-start side, as appropriate. When used outside of a flex formatting context, this value behaves as start. That is, on boxes that are not flex items (or pretending to be flex items, such as when determining the static position of an absolutely-positioned box that is a child of a flex container), this value behaves as start when used in the self-alignment properties, and on boxes that are not flex containers, this value behaves as start when used in the content-distribution properties.",
                "type": "value",
                "value": "flex-start"
            },
            {
                "name": "flex-end",
                "prose": "Only used in flex layout. Aligns the alignment subject to be flush with the edge of the alignment container corresponding to the flex container’s main-end or cross-end side, as appropriate. When used outside of a flex formatting context, this value behaves as end. That is, on boxes that are not flex items (or pretending to be flex items, such as when determining the static position of an absolutely-positioned box that is a child of a flex container), this value behaves as end when used in the self-alignment properties, and on boxes that are not flex containers, this value behaves as end when used in the content-distribution properties.",
                "type": "value",
                "value": "flex-end"
            }
        ]
    },
    "<content-position>": {
        "name": "<content-position>",
        "type": "type",
        "value": "center | start | end | flex-start | flex-end",
        "values": [
            {
                "name": "center",
                "prose": "Centers the alignment subject within its alignment container.",
                "type": "value",
                "value": "center"
            },
            {
                "name": "start",
                "prose": "Aligns the alignment subject to be flush with the alignment container’s start edge in the appropriate axis.",
                "type": "value",
                "value": "start"
            },
            {
                "name": "end",
                "prose": "Aligns the alignment subject to be flush with the alignment container’s end edge in the appropriate axis.",
                "type": "value",
                "value": "end"
            },
            {
                "name": "flex-start",
                "prose": "Only used in flex layout. [CSS-FLEXBOX-1] Aligns the alignment subject to be flush with the edge of the alignment container corresponding to the flex container’s main-start or cross-start side, as appropriate. When used outside of a flex formatting context, this value behaves as start. That is, on boxes that are not flex items (or pretending to be flex items, such as when determining the static position of an absolutely-positioned box that is a child of a flex container), this value behaves as start when used in the self-alignment properties, and on boxes that are not flex containers, this value behaves as start when used in the content-distribution properties.",
                "type": "value",
                "value": "flex-start"
            },
            {
                "name": "flex-end",
                "prose": "Only used in flex layout. Aligns the alignment subject to be flush with the edge of the alignment container corresponding to the flex container’s main-end or cross-end side, as appropriate. When used outside of a flex formatting context, this value behaves as end. That is, on boxes that are not flex items (or pretending to be flex items, such as when determining the static position of an absolutely-positioned box that is a child of a flex container), this value behaves as end when used in the self-alignment properties, and on boxes that are not flex containers, this value behaves as end when used in the content-distribution properties.",
                "type": "value",
                "value": "flex-end"
            }
        ]
    },
    "<baseline-position>": {
        "name": "<baseline-position>",
        "type": "type",
        "value": "[ first | last ]? && baseline",
        "values": [
            {
                "name": "baseline",
                "prose": "Computes to first baseline, defined below.",
                "type": "value",
                "value": "baseline"
            },
            {
                "name": "first baseline",
                "prose": "Specifies participation in first-baseline alignment: aligns the alignment baseline of the box’s first baseline set with the corresponding baseline of its baseline-sharing group. See § 9.3 Aligning Boxes by Baseline for more details. The fallback alignment for first baseline is safe self-start (for self-alignment) or safe start (for content-distribution).",
                "type": "value",
                "value": "first baseline"
            },
            {
                "name": "last baseline",
                "prose": "Specifies participation in last-baseline alignment: aligns the alignment baseline of the box’s last baseline set with the corresponding baseline of its baseline-sharing group.̣ See § 9.3 Aligning Boxes by Baseline for more details. The fallback alignment for last baseline is safe self-end (for self-alignment) or safe end (for content-distribution).",
                "type": "value",
                "value": "last baseline"
            }
        ]
    },
    "<content-distribution>": {
        "name": "<content-distribution>",
        "type": "type",
        "value": "space-between | space-around | space-evenly | stretch",
        "values": [
            {
                "name": "space-between",
                "prose": "The alignment subjects are evenly distributed in the alignment container. The first alignment subject is placed flush with the start edge of the alignment container, the last alignment subject is placed flush with the end edge of the alignment container, and the remaining alignment subjects are distributed so that the spacing between any two adjacent alignment subjects is the same. The default fallback alignment for this value is flex-start. (For layout modes other than flex layout, flex-start is identical to start.)",
                "type": "value",
                "value": "space-between"
            },
            {
                "name": "space-around",
                "prose": "The alignment subjects are evenly distributed in the alignment container, with a half-size space on either end. The alignment subjects are distributed so that the spacing between any two adjacent alignment subjects is the same, and the spacing before the first and after the last alignment subject is half the size of the other spacing. The default fallback alignment for this value is safe center.",
                "type": "value",
                "value": "space-around"
            },
            {
                "name": "space-evenly",
                "prose": "The alignment subjects are evenly distributed in the alignment container, with a full-size space on either end. The alignment subjects are distributed so that the spacing between any two adjacent alignment subjects, before the first alignment subject, and after the last alignment subject is the same. The default fallback alignment for this value is safe center.",
                "type": "value",
                "value": "space-evenly"
            },
            {
                "name": "stretch",
                "prose": "If the combined size of the alignment subjects is less than the size of the alignment container, any auto-sized alignment subjects have their size increased equally (not proportionally), while still respecting the constraints imposed by max-height/max-width (or equivalent functionality), so that the combined size exactly fills the alignment container. The default fallback alignment for this value is flex-start. (For layout modes other than flex layout, flex-start is identical to start.)",
                "type": "value",
                "value": "stretch"
            }
        ]
    },
    "<overflow-position>": {
        "name": "<overflow-position>",
        "type": "type",
        "value": "unsafe | safe",
        "values": [
            {
                "name": "safe",
                "prose": "If the size of the alignment subject overflows the alignment container, the alignment subject is instead aligned as if the alignment mode were start.",
                "type": "value",
                "value": "safe"
            },
            {
                "name": "unsafe",
                "prose": "Regardless of the relative sizes of the alignment subject and alignment container, the given alignment value is honored.",
                "type": "value",
                "value": "unsafe"
            }
        ]
    },
    "anchor()": {
        "name": "anchor()",
        "prose": "An absolutely-positioned element can use the anchor() function as a value in its inset properties to refer to the position of one or more anchor elements. The anchor() function resolves to a <length>.",
        "type": "function",
        "value": "anchor( <anchor-element>? <anchor-side>, <length-percentage>? )",
        "values": [
            {
                "name": "<dashed-ident>",
                "prose": "Specifies the anchor name it will look for. This name is a tree-scoped reference.",
                "type": "value",
                "value": "<dashed-ident>"
            },
            {
                "name": "implicit",
                "prose": "Selects the implicit anchor element defined for the element, if possible.",
                "type": "value",
                "value": "implicit"
            },
            {
                "name": "auto",
                "prose": "The auto and auto-same keywords indicate automatic anchor positioning. See § 2.1.1 Automatic Anchor Positioning for details.",
                "type": "value",
                "value": "auto"
            },
            {
                "name": "auto-same",
                "prose": "The auto and auto-same keywords indicate automatic anchor positioning. See § 2.1.1 Automatic Anchor Positioning for details.",
                "type": "value",
                "value": "auto-same"
            },
            {
                "name": "left",
                "prose": "The physical <anchor-side> keywords (left, right, top, and bottom) are only useful in inset properties corresponding to their corresponding axis: for example, using top and bottom in left or right (or in inset-inline-start if the inline axis is horizontal, etc) results in an invalid anchor query.",
                "type": "value",
                "value": "left"
            },
            {
                "name": "right",
                "prose": "The physical <anchor-side> keywords (left, right, top, and bottom) are only useful in inset properties corresponding to their corresponding axis: for example, using top and bottom in left or right (or in inset-inline-start if the inline axis is horizontal, etc) results in an invalid anchor query.",
                "type": "value",
                "value": "right"
            },
            {
                "name": "top",
                "prose": "The physical <anchor-side> keywords (left, right, top, and bottom) are only useful in inset properties corresponding to their corresponding axis: for example, using top and bottom in left or right (or in inset-inline-start if the inline axis is horizontal, etc) results in an invalid anchor query.",
                "type": "value",
                "value": "top"
            },
            {
                "name": "bottom",
                "prose": "The physical <anchor-side> keywords (left, right, top, and bottom) are only useful in inset properties corresponding to their corresponding axis: for example, using top and bottom in left or right (or in inset-inline-start if the inline axis is horizontal, etc) results in an invalid anchor query.",
                "type": "value",
                "value": "bottom"
            },
            {
                "name": "start",
                "prose": "The logical <anchor-side> keywords (start, end, self-start, and self-end) map to one of the physical keywords depending on the property the function is being used in (top or bottom in the top or bottom properties, etc) and the writing mode of either the element (for self-start and self-end) or the writing mode of the element’s containing block (for start and end).",
                "type": "value",
                "value": "start"
            },
            {
                "name": "end",
                "prose": "The logical <anchor-side> keywords (start, end, self-start, and self-end) map to one of the physical keywords depending on the property the function is being used in (top or bottom in the top or bottom properties, etc) and the writing mode of either the element (for self-start and self-end) or the writing mode of the element’s containing block (for start and end).",
                "type": "value",
                "value": "end"
            },
            {
                "name": "self-start",
                "prose": "The logical <anchor-side> keywords (start, end, self-start, and self-end) map to one of the physical keywords depending on the property the function is being used in (top or bottom in the top or bottom properties, etc) and the writing mode of either the element (for self-start and self-end) or the writing mode of the element’s containing block (for start and end).",
                "type": "value",
                "value": "self-start"
            },
            {
                "name": "self-end",
                "prose": "The logical <anchor-side> keywords (start, end, self-start, and self-end) map to one of the physical keywords depending on the property the function is being used in (top or bottom in the top or bottom properties, etc) and the writing mode of either the element (for self-start and self-end) or the writing mode of the element’s containing block (for start and end).",
                "type": "value",
                "value": "self-end"
            },
            {
                "name": "center",
                "prose": "A <percentage> value refers to a position a corresponding percentage between the start and end sides, with 0% being equivalent to start and 100% being equivalent to end. The center keyword is equivalent to 50%.",
                "type": "value",
                "value": "center"
            }
        ]
    },
    "<anchor-element>": {
        "name": "<anchor-element>",
        "type": "type",
        "value": "<dashed-ident> | implicit"
    },
    "<anchor-side>": {
        "name": "<anchor-side>",
        "type": "type",
        "value": "auto | auto-same | top | left | right | bottom | start | end | self-start | self-end | <percentage> | center"
    },
    "anchor-size()": {
        "name": "anchor-size()",
        "prose": "An absolutely-positioned element can use the anchor-size() function in its sizing properties to refer to the size of one or more anchor elements. The anchor-size() function resolves to a <length>.",
        "type": "function",
        "value": "anchor( <anchor-element>? <anchor-size>, <length-percentage>? )",
        "values": [
            {
                "name": "width",
                "prose": "The physical <anchor-size> keywords (width and height) refer to the width and height, respectively, of the target anchor element. Unlike anchor(), there is no restriction on having to match axises; for example, width: anchor-size(--foo height); is valid.",
                "type": "value",
                "value": "width"
            },
            {
                "name": "height",
                "prose": "The physical <anchor-size> keywords (width and height) refer to the width and height, respectively, of the target anchor element. Unlike anchor(), there is no restriction on having to match axises; for example, width: anchor-size(--foo height); is valid.",
                "type": "value",
                "value": "height"
            },
            {
                "name": "block",
                "prose": "The logical <anchor-size> keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).",
                "type": "value",
                "value": "block"
            },
            {
                "name": "inline",
                "prose": "The logical <anchor-size> keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).",
                "type": "value",
                "value": "inline"
            },
            {
                "name": "self-block",
                "prose": "The logical <anchor-size> keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).",
                "type": "value",
                "value": "self-block"
            },
            {
                "name": "self-inline",
                "prose": "The logical <anchor-size> keywords (block, inline, self-block, and self-inline) map to one of the physical keywords according to either the writing mode of the element (for self-block and self-inline) or the writing mode of the element’s containing block (for block and inline).",
                "type": "value",
                "value": "self-inline"
            }
        ]
    },
    "<anchor-size>": {
        "name": "<anchor-size>",
        "type": "type",
        "value": "width | height | block | inline | self-block | self-inline"
    },
    "<single-animation-composition>": {
        "name": "<single-animation-composition>",
        "value": "replace | add | accumulate",
        "type": "type"
    },
    "<single-animation-timeline>": {
        "name": "<single-animation-timeline>",
        "type": "type",
        "value": "auto | none | <custom-ident> | <scroll()> | <view()>",
        "values": [
            {
                "name": "auto",
                "prose": "The animation’s timeline is a DocumentTimeline, more specifically the default document timeline.",
                "type": "value",
                "value": "auto"
            },
            {
                "name": "none",
                "prose": "The animation is not associated with a timeline.",
                "type": "value",
                "value": "none"
            },
            {
                "name": "<custom-ident>",
                "prose": "If a named scroll progress timeline or view progress timeline is in scope on this element, use the referenced timeline as defined in Scroll-linked Animations § 4 Named Timeline Scoping. Otherwise the animation is not associated with a timeline.",
                "type": "value",
                "value": "<custom-ident>"
            },
            {
                "name": "<scroll()>",
                "prose": "Use the scroll progress timeline indicated by the given scroll() function. See Scroll-linked Animations § 2.1.1 The scroll() notation.",
                "type": "value",
                "value": "<scroll()>"
            },
            {
                "name": "<view()>",
                "prose": "Use the view progress timeline indicated by the given view() function. See Scroll-linked Animations § 3.2.1 The view() notation.",
                "type": "value",
                "value": "<view()>"
            }
        ]
    },
    "<single-animation>": {
        "name": "<single-animation>",
        "value": "<time [0s,∞]> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]",
        "type": "type"
    },
    "<keyframes-name>": {
        "name": "<keyframes-name>",
        "type": "type",
        "value": "<custom-ident> | <string>"
    },
    "<keyframe-block>": {
        "name": "<keyframe-block>",
        "type": "type",
        "value": "<keyframe-selector># { <declaration-list> }"
    },
    "<keyframe-selector>": {
        "name": "<keyframe-selector>",
        "type": "type",
        "value": "from | to | <percentage [0,100]>"
    },
    "<single-animation-iteration-count>": {
        "name": "<single-animation-iteration-count>",
        "value": "infinite | <number [0,∞]>",
        "type": "type"
    },
    "<single-animation-direction>": {
        "name": "<single-animation-direction>",
        "value": "normal | reverse | alternate | alternate-reverse",
        "type": "type"
    },
    "<single-animation-play-state>": {
        "name": "<single-animation-play-state>",
        "value": "running | paused",
        "type": "type"
    },
    "<single-animation-fill-mode>": {
        "name": "<single-animation-fill-mode>",
        "value": "none | forwards | backwards | both",
        "type": "type"
    },
    "<bg-clip>": {
        "name": "<bg-clip>",
        "type": "type",
        "value": "<box> | border | text",
        "values": [
            {
                "name": "<box>",
                "prose": "The background is painted within (clipped to) the specified box of the element.",
                "type": "value",
                "value": "<box>"
            },
            {
                "name": "text",
                "prose": "The background is painted within (clipped to) the intersection of the border box and the geometry of the text in the element and its in-flow and floated descendants.",
                "type": "value",
                "value": "text"
            },
            {
                "name": "border",
                "prose": "The background is clipped to the area painted by the border, taking border-width and border-style into account but ignoring any transparency introduced by border-color.",
                "type": "value",
                "value": "border"
            }
        ]
    },
    "<spread-shadow>": {
        "name": "<spread-shadow>",
        "type": "type",
        "value": "<'box-shadow-color'>? && [ <'box-shadow-offset'> [ <'box-shadow-blur'> <'box-shadow-spread'>? ]? ] && <'box-shadow-position'>?"
    },
    "<bg-image>": {
        "name": "<bg-image>",
        "type": "type",
        "value": "<image> | none"
    },
    "<repeat-style>": {
        "name": "<repeat-style>",
        "type": "type",
        "value": "repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}"
    },
    "<attachment>": {
        "name": "<attachment>",
        "type": "type",
        "value": "scroll | fixed | local"
    },
    "<bg-position>": {
        "name": "<bg-position>",
        "type": "type",
        "value": "[ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ]"
    },
    "<box>": {
        "name": "<box>",
        "type": "type",
        "value": "border-box | padding-box | content-box"
    },
    "<bg-size>": {
        "name": "<bg-size>",
        "type": "type",
        "value": "[ <length-percentage [0,∞]> | auto ]{1,2} | cover | contain"
    },
    "<bg-layer>": {
        "name": "<bg-layer>",
        "type": "type",
        "value": "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
    },
    "<final-bg-layer>": {
        "name": "<final-bg-layer>",
        "type": "type",
        "value": "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box> || <'background-color'>"
    },
    "<line-style>": {
        "name": "<line-style>",
        "type": "type",
        "value": "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset",
        "values": [
            {
                "name": "none",
                "prose": "No border. Color and width are ignored (i.e., the border has width 0). Note this means that the initial value of border-image-width will also resolve to zero.",
                "type": "value",
                "value": "none"
            },
            {
                "name": "hidden",
                "prose": "Same as none, but has different behavior in the border conflict resolution rules for border-collapsed tables [CSS2].",
                "type": "value",
                "value": "hidden"
            },
            {
                "name": "dotted",
                "prose": "A series of round dots.",
                "type": "value",
                "value": "dotted"
            },
            {
                "name": "dashed",
                "prose": "A series of square-ended dashes.",
                "type": "value",
                "value": "dashed"
            },
            {
                "name": "solid",
                "prose": "A single line segment.",
                "type": "value",
                "value": "solid"
            },
            {
                "name": "double",
                "prose": "Two parallel solid lines with some space between them. (The thickness of the lines is not specified, but the sum of the lines and the space must equal border-width.)",
                "type": "value",
                "value": "double"
            },
            {
                "name": "groove",
                "prose": "Looks as if it were carved in the canvas. (This is typically achieved by creating a “shadow” from two colors that are slightly lighter and darker than the border-color.)",
                "type": "value",
                "value": "groove"
            },
            {
                "name": "ridge",
                "prose": "Looks as if it were coming out of the canvas.",
                "type": "value",
                "value": "ridge"
            },
            {
                "name": "inset",
                "prose": "Looks as if the content on the inside of the border is sunken into the canvas. Treated as ridge in the collapsing border model. [CSS2]",
                "type": "value",
                "value": "inset"
            },
            {
                "name": "outset",
                "prose": "Looks as if the content on the inside of the border is coming out of the canvas. Treated as groove in the collapsing border model. [CSS2]",
                "type": "value",
                "value": "outset"
            }
        ]
    },
    "<line-width>": {
        "name": "<line-width>",
        "type": "type",
        "value": "<length [0,∞]> | thin | medium | thick",
        "values": [
            {
                "name": "thin",
                "prose": "Negative values are invalid. The thin, medium, and thick keywords are equivalent to 1px, 3px, and 5px, respectively.",
                "type": "value",
                "value": "thin"
            },
            {
                "name": "medium",
                "prose": "Negative values are invalid. The thin, medium, and thick keywords are equivalent to 1px, 3px, and 5px, respectively.",
                "type": "value",
                "value": "medium"
            },
            {
                "name": "thick",
                "prose": "Negative values are invalid. The thin, medium, and thick keywords are equivalent to 1px, 3px, and 5px, respectively.",
                "type": "value",
                "value": "thick"
            }
        ]
    },
    "<shadow>": {
        "name": "<shadow>",
        "type": "type",
        "value": "<color>? && [<length>{2} <length [0,∞]>? <length>?] && inset?"
    },
    "<visual-box>": {
        "name": "<visual-box>",
        "type": "type",
        "value": "content-box | padding-box | border-box"
    },
    "<layout-box>": {
        "name": "<layout-box>",
        "type": "type",
        "value": "content-box | padding-box | border-box | margin-box"
    },
    "<paint-box>": {
        "name": "<paint-box>",
        "type": "type",
        "value": "content-box | padding-box | border-box | fill-box | stroke-box"
    },
    "<coord-box>": {
        "name": "<coord-box>",
        "type": "type",
        "value": "content-box | padding-box | border-box | fill-box | stroke-box | view-box"
    },
    "<scope-start>": {
        "name": "<scope-start>",
        "prose": "<scope-start> is a <forgiving-selector-list> selector used to identify the scoping root(s).",
        "type": "type"
    },
    "<scope-end>": {
        "name": "<scope-end>",
        "prose": "<scope-end> is a <forgiving-selector-list> selector used to identify any scoping limits.",
        "type": "type"
    },
    "<import-conditions>": {
        "name": "<import-conditions>",
        "type": "type",
        "value": "[ supports( [ <supports-condition> | <declaration> ] ) ]? <media-query-list>?"
    },
    "<layer-name>": {
        "name": "<layer-name>",
        "type": "type",
        "value": "<ident> [ '.' <ident> ]*"
    },
    "<color>": {
        "name": "<color>",
        "prose": "Colors in CSS are represented by the <color> type:",
        "type": "type",
        "value": "<absolute-color-base> | currentcolor | <system-color>",
        "values": [
            {
                "name": "none",
                "prose": "It can also be specified explicitly, by providing the keyword none for a component in a color function. All color functions (with the exception of those using the legacy color syntax) allow any of their components to be specified as none.",
                "type": "value",
                "value": "none"
            },
            {
                "name": "aliceblue",
                "type": "value",
                "value": "aliceblue"
            },
            {
                "name": "antiquewhite",
                "type": "value",
                "value": "antiquewhite"
            },
            {
                "name": "aqua",
                "type": "value",
                "value": "aqua"
            },
            {
                "name": "aquamarine",
                "type": "value",
                "value": "aquamarine"
            },
            {
                "name": "azure",
                "type": "value",
                "value": "azure"
            },
            {
                "name": "beige",
                "type": "value",
                "value": "beige"
            },
            {
                "name": "bisque",
                "type": "value",
                "value": "bisque"
            },
            {
                "name": "black",
                "type": "value",
                "value": "black"
            },
            {
                "name": "blanchedalmond",
                "type": "value",
                "value": "blanchedalmond"
            },
            {
                "name": "blue",
                "type": "value",
                "value": "blue"
            },
            {
                "name": "blueviolet",
                "type": "value",
                "value": "blueviolet"
            },
            {
                "name": "brown",
                "type": "value",
                "value": "brown"
            },
            {
                "name": "burlywood",
                "type": "value",
                "value": "burlywood"
            },
            {
                "name": "cadetblue",
                "type": "value",
                "value": "cadetblue"
            },
            {
                "name": "chartreuse",
                "type": "value",
                "value": "chartreuse"
            },
            {
                "name": "chocolate",
                "type": "value",
                "value": "chocolate"
            },
            {
                "name": "coral",
                "type": "value",
                "value": "coral"
            },
            {
                "name": "cornflowerblue",
                "type": "value",
                "value": "cornflowerblue"
            },
            {
                "name": "cornsilk",
                "type": "value",
                "value": "cornsilk"
            },
            {
                "name": "crimson",
                "type": "value",
                "value": "crimson"
            },
            {
                "name": "cyan",
                "type": "value",
                "value": "cyan"
            },
            {
                "name": "darkblue",
                "type": "value",
                "value": "darkblue"
            },
            {
                "name": "darkcyan",
                "type": "value",
                "value": "darkcyan"
            },
            {
                "name": "darkgoldenrod",
                "type": "value",
                "value": "darkgoldenrod"
            },
            {
                "name": "darkgray",
                "type": "value",
                "value": "darkgray"
            },
            {
                "name": "darkgreen",
                "type": "value",
                "value": "darkgreen"
            },
            {
                "name": "darkgrey",
                "type": "value",
                "value": "darkgrey"
            },
            {
                "name": "darkkhaki",
                "type": "value",
                "value": "darkkhaki"
            },
            {
                "name": "darkmagenta",
                "type": "value",
                "value": "darkmagenta"
            },
            {
                "name": "darkolivegreen",
                "type": "value",
                "value": "darkolivegreen"
            },
            {
                "name": "darkorange",
                "type": "value",
                "value": "darkorange"
            },
            {
                "name": "darkorchid",
                "type": "value",
                "value": "darkorchid"
            },
            {
                "name": "darkred",
                "type": "value",
                "value": "darkred"
            },
            {
                "name": "darksalmon",
                "type": "value",
                "value": "darksalmon"
            },
            {
                "name": "darkseagreen",
                "type": "value",
                "value": "darkseagreen"
            },
            {
                "name": "darkslateblue",
                "type": "value",
                "value": "darkslateblue"
            },
            {
                "name": "darkslategray",
                "type": "value",
                "value": "darkslategray"
            },
            {
                "name": "darkslategrey",
                "type": "value",
                "value": "darkslategrey"
            },
            {
                "name": "darkturquoise",
                "type": "value",
                "value": "darkturquoise"
            },
            {
                "name": "darkviolet",
                "type": "value",
                "value": "darkviolet"
            },
            {
                "name": "deeppink",
                "type": "value",
                "value": "deeppink"
            },
            {
                "name": "deepskyblue",
                "type": "value",
                "value": "deepskyblue"
            },
            {
                "name": "dimgray",
                "type": "value",
                "value": "dimgray"
            },
            {
                "name": "dimgrey",
                "type": "value",
                "value": "dimgrey"
            },
            {
                "name": "dodgerblue",
                "type": "value",
                "value": "dodgerblue"
            },
            {
                "name": "firebrick",
                "type": "value",
                "value": "firebrick"
            },
            {
                "name": "floralwhite",
                "type": "value",
                "value": "floralwhite"
            },
            {
                "name": "forestgreen",
                "type": "value",
                "value": "forestgreen"
            },
            {
                "name": "fuchsia",
                "type": "value",
                "value": "fuchsia"
            },
            {
                "name": "gainsboro",
                "type": "value",
                "value": "gainsboro"
            },
            {
                "name": "ghostwhite",
                "type": "value",
                "value": "ghostwhite"
            },
            {
                "name": "gold",
                "type": "value",
                "value": "gold"
            },
            {
                "name": "goldenrod",
                "type": "value",
                "value": "goldenrod"
            },
            {
                "name": "gray",
                "type": "value",
                "value": "gray"
            },
            {
                "name": "green",
                "type": "value",
                "value": "green"
            },
            {
                "name": "greenyellow",
                "type": "value",
                "value": "greenyellow"
            },
            {
                "name": "grey",
                "type": "value",
                "value": "grey"
            },
            {
                "name": "honeydew",
                "type": "value",
                "value": "honeydew"
            },
            {
                "name": "hotpink",
                "type": "value",
                "value": "hotpink"
            },
            {
                "name": "indianred",
                "type": "value",
                "value": "indianred"
            },
            {
                "name": "indigo",
                "type": "value",
                "value": "indigo"
            },
            {
                "name": "ivory",
                "type": "value",
                "value": "ivory"
            },
            {
                "name": "khaki",
                "type": "value",
                "value": "khaki"
            },
            {
                "name": "lavender",
                "type": "value",
                "value": "lavender"
            },
            {
                "name": "lavenderblush",
                "type": "value",
                "value": "lavenderblush"
            },
            {
                "name": "lawngreen",
                "type": "value",
                "value": "lawngreen"
            },
            {
                "name": "lemonchiffon",
                "type": "value",
                "value": "lemonchiffon"
            },
            {
                "name": "lightblue",
                "type": "value",
                "value": "lightblue"
            },
            {
                "name": "lightcoral",
                "type": "value",
                "value": "lightcoral"
            },
            {
                "name": "lightcyan",
                "type": "value",
                "value": "lightcyan"
            },
            {
                "name": "lightgoldenrodyellow",
                "type": "value",
                "value": "lightgoldenrodyellow"
            },
            {
                "name": "lightgray",
                "type": "value",
                "value": "lightgray"
            },
            {
                "name": "lightgreen",
                "type": "value",
                "value": "lightgreen"
            },
            {
                "name": "lightgrey",
                "type": "value",
                "value": "lightgrey"
            },
            {
                "name": "lightpink",
                "type": "value",
                "value": "lightpink"
            },
            {
                "name": "lightsalmon",
                "type": "value",
                "value": "lightsalmon"
            },
            {
                "name": "lightseagreen",
                "type": "value",
                "value": "lightseagreen"
            },
            {
                "name": "lightskyblue",
                "type": "value",
                "value": "lightskyblue"
            },
            {
                "name": "lightslategray",
                "type": "value",
                "value": "lightslategray"
            },
            {
                "name": "lightslategrey",
                "type": "value",
                "value": "lightslategrey"
            },
            {
                "name": "lightsteelblue",
                "type": "value",
                "value": "lightsteelblue"
            },
            {
                "name": "lightyellow",
                "type": "value",
                "value": "lightyellow"
            },
            {
                "name": "lime",
                "type": "value",
                "value": "lime"
            },
            {
                "name": "limegreen",
                "type": "value",
                "value": "limegreen"
            },
            {
                "name": "linen",
                "type": "value",
                "value": "linen"
            },
            {
                "name": "magenta",
                "type": "value",
                "value": "magenta"
            },
            {
                "name": "maroon",
                "type": "value",
                "value": "maroon"
            },
            {
                "name": "mediumaquamarine",
                "type": "value",
                "value": "mediumaquamarine"
            },
            {
                "name": "mediumblue",
                "type": "value",
                "value": "mediumblue"
            },
            {
                "name": "mediumorchid",
                "type": "value",
                "value": "mediumorchid"
            },
            {
                "name": "mediumpurple",
                "type": "value",
                "value": "mediumpurple"
            },
            {
                "name": "mediumseagreen",
                "type": "value",
                "value": "mediumseagreen"
            },
            {
                "name": "mediumslateblue",
                "type": "value",
                "value": "mediumslateblue"
            },
            {
                "name": "mediumspringgreen",
                "type": "value",
                "value": "mediumspringgreen"
            },
            {
                "name": "mediumturquoise",
                "type": "value",
                "value": "mediumturquoise"
            },
            {
                "name": "mediumvioletred",
                "type": "value",
                "value": "mediumvioletred"
            },
            {
                "name": "midnightblue",
                "type": "value",
                "value": "midnightblue"
            },
            {
                "name": "mintcream",
                "type": "value",
                "value": "mintcream"
            },
            {
                "name": "mistyrose",
                "type": "value",
                "value": "mistyrose"
            },
            {
                "name": "moccasin",
                "type": "value",
                "value": "moccasin"
            },
            {
                "name": "navajowhite",
                "type": "value",
                "value": "navajowhite"
            },
            {
                "name": "navy",
                "type": "value",
                "value": "navy"
            },
            {
                "name": "oldlace",
                "type": "value",
                "value": "oldlace"
            },
            {
                "name": "olive",
                "type": "value",
                "value": "olive"
            },
            {
                "name": "olivedrab",
                "type": "value",
                "value": "olivedrab"
            },
            {
                "name": "orange",
                "type": "value",
                "value": "orange"
            },
            {
                "name": "orangered",
                "type": "value",
                "value": "orangered"
            },
            {
                "name": "orchid",
                "type": "value",
                "value": "orchid"
            },
            {
                "name": "palegoldenrod",
                "type": "value",
                "value": "palegoldenrod"
            },
            {
                "name": "palegreen",
                "type": "value",
                "value": "palegreen"
            },
            {
                "name": "paleturquoise",
                "type": "value",
                "value": "paleturquoise"
            },
            {
                "name": "palevioletred",
                "type": "value",
                "value": "palevioletred"
            },
            {
                "name": "papayawhip",
                "type": "value",
                "value": "papayawhip"
            },
            {
                "name": "peachpuff",
                "type": "value",
                "value": "peachpuff"
            },
            {
                "name": "peru",
                "type": "value",
                "value": "peru"
            },
            {
                "name": "pink",
                "type": "value",
                "value": "pink"
            },
            {
                "name": "plum",
                "type": "value",
                "value": "plum"
            },
            {
                "name": "powderblue",
                "type": "value",
                "value": "powderblue"
            },
            {
                "name": "purple",
                "type": "value",
                "value": "purple"
            },
            {
                "name": "rebeccapurple",
                "type": "value",
                "value": "rebeccapurple"
            },
            {
                "name": "red",
                "type": "value",
                "value": "red"
            },
            {
                "name": "rosybrown",
                "type": "value",
                "value": "rosybrown"
            },
            {
                "name": "royalblue",
                "type": "value",
                "value": "royalblue"
            },
            {
                "name": "saddlebrown",
                "type": "value",
                "value": "saddlebrown"
            },
            {
                "name": "salmon",
                "type": "value",
                "value": "salmon"
            },
            {
                "name": "sandybrown",
                "type": "value",
                "value": "sandybrown"
            },
            {
                "name": "seagreen",
                "type": "value",
                "value": "seagreen"
            },
            {
                "name": "seashell",
                "type": "value",
                "value": "seashell"
            },
            {
                "name": "sienna",
                "type": "value",
                "value": "sienna"
            },
            {
                "name": "silver",
                "type": "value",
                "value": "silver"
            },
            {
                "name": "skyblue",
                "type": "value",
                "value": "skyblue"
            },
            {
                "name": "slateblue",
                "type": "value",
                "value": "slateblue"
            },
            {
                "name": "slategray",
                "type": "value",
                "value": "slategray"
            },
            {
                "name": "slategrey",
                "type": "value",
                "value": "slategrey"
            },
            {
                "name": "snow",
                "type": "value",
                "value": "snow"
            },
            {
                "name": "springgreen",
                "type": "value",
                "value": "springgreen"
            },
            {
                "name": "steelblue",
                "type": "value",
                "value": "steelblue"
            },
            {
                "name": "tan",
                "type": "value",
                "value": "tan"
            },
            {
                "name": "teal",
                "type": "value",
                "value": "teal"
            },
            {
                "name": "thistle",
                "type": "value",
                "value": "thistle"
            },
            {
                "name": "tomato",
                "type": "value",
                "value": "tomato"
            },
            {
                "name": "turquoise",
                "type": "value",
                "value": "turquoise"
            },
            {
                "name": "violet",
                "type": "value",
                "value": "violet"
            },
            {
                "name": "wheat",
                "type": "value",
                "value": "wheat"
            },
            {
                "name": "white",
                "type": "value",
                "value": "white"
            },
            {
                "name": "whitesmoke",
                "type": "value",
                "value": "whitesmoke"
            },
            {
                "name": "yellow",
                "type": "value",
                "value": "yellow"
            },
            {
                "name": "yellowgreen",
                "type": "value",
                "value": "yellowgreen"
            },
            {
                "name": "transparent",
                "prose": "The keyword transparent specifies a transparent black. It is a type of <named-color>.",
                "type": "value",
                "value": "transparent"
            },
            {
                "name": "currentcolor",
                "prose": "The keyword currentcolor represents value of the color property on the same element. Unlike <named-color>s, it is not restricted to sRGB; the value can be any <color>. Its used values is determined by resolving color values.",
                "type": "value",
                "value": "currentcolor"
            }
        ]
    },
    "<absolute-color-base>": {
        "name": "<absolute-color-base>",
        "type": "type",
        "value": "<hex-color> | <absolute-color-function> | <named-color> | transparent"
    },
    "<absolute-color-function>": {
        "name": "<absolute-color-function>",
        "type": "type",
        "value": "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <oklab()> | <oklch()> | <color()>"
    },
    "color-mix()": {
        "name": "color-mix()",
        "type": "function",
        "value": "color-mix( <color-interpolation-method> , [ <color> && <percentage [0,100]>? ]#{2})"
    },
    "<modern-rgb-syntax>": {
        "name": "<modern-rgb-syntax>",
        "type": "type",
        "value": "rgb( [ <number> | <percentage> | none]{3} [ / [<alpha-value> | none] ]? )"
    },
    "<modern-rgba-syntax>": {
        "name": "<modern-rgba-syntax>",
        "type": "type",
        "value": "rgba( [ <number> | <percentage> | none]{3} [ / [<alpha-value> | none] ]? )"
    },
    "<modern-hsl-syntax>": {
        "name": "<modern-hsl-syntax>",
        "type": "type",
        "value": "hsl( [<hue> | none] [<percentage> | <number> | none] [<percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
    },
    "<modern-hsla-syntax>": {
        "name": "<modern-hsla-syntax>",
        "type": "type",
        "value": "hsla( [<hue> | none] [<percentage> | <number> | none] [<percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
    },
    "hwb()": {
        "name": "hwb()",
        "type": "function",
        "value": "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )",
        "values": [
            {
                "name": "HWB",
                "prose": "HWB (short for Hue-Whiteness-Blackness) [HWB] is another method of specifying sRGB colors, similar to HSL', but often even easier for humans to work with. It describes colors with a starting hue, then a degree of whiteness and blackness to mix into that base hue.",
                "type": "value",
                "value": "HWB"
            }
        ]
    },
    "lab()": {
        "name": "lab()",
        "type": "function",
        "value": "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )",
        "values": [
            {
                "name": "Lab",
                "prose": "Lab is a rectangular coordinate system with a central Lightness (L) axis. This value is usually written as a unitless number; for compatibility with the rest of CSS, it may also be written as a percentage. 100% means an L value of 100, not 1.0. L=0% or 0 is deep black (no light at all) while L=100% or 100 is a diffuse white.",
                "type": "value",
                "value": "Lab"
            }
        ]
    },
    "oklab()": {
        "name": "oklab()",
        "type": "function",
        "value": "oklab( [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )",
        "values": [
            {
                "name": "Oklab",
                "prose": "Recently, Oklab, an improved Lab-like space has been developed [Oklab]. The corresponding polar form is called Oklch. It was produced by numerical optimisation of a large dataset of visually similar colors, and has improved hue linearity, hue uniformity, and chroma uniformity compared to CIE LCH.",
                "type": "value",
                "value": "Oklab"
            }
        ]
    },
    "lch()": {
        "name": "lch()",
        "type": "function",
        "value": "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )",
        "values": [
            {
                "name": "LCH",
                "prose": "CIE LCH has the same L axis as Lab, but uses polar coordinates C (chroma) and H (hue), making it a polar, cylindrical coordinate system. C is the geometric distance from the L axis and H is the angle from the positive a axis, towards the positive b axis.",
                "type": "value",
                "value": "LCH"
            }
        ]
    },
    "oklch()": {
        "name": "oklch()",
        "type": "function",
        "value": "oklch( [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )",
        "values": [
            {
                "name": "Oklch",
                "prose": "Recently, Oklab, an improved Lab-like space has been developed [Oklab]. The corresponding polar form is called Oklch. It was produced by numerical optimisation of a large dataset of visually similar colors, and has improved hue linearity, hue uniformity, and chroma uniformity compared to CIE LCH.",
                "type": "value",
                "value": "Oklch"
            }
        ]
    },
    "color()": {
        "name": "color()",
        "type": "function",
        "value": "color( <colorspace-params> [ / [ <alpha-value> | none ] ]? )",
        "values": [
            {
                "name": "srgb",
                "prose": "The srgb [SRGB] color space accepts three numeric parameters, representing the red, green, and blue channels of the color. In-gamut colors have all three components in the range [0, 1]. The whitepoint is D65. [SRGB] specifies two viewing conditions, encoding and typical. The [ICC] recommends using the encoding conditions for color conversion and for optimal viewing, which are the values in the table below. sRGB is the default color space for CSS, used for all the legacy color functions. It has the following characteristics: x y Red chromaticity 0.640 0.330 Green chromaticity 0.300 0.600 Blue chromaticity 0.150 0.060 White chromaticity D65 Transfer function see below White luminance 80.0 cd/m Black luminance 0.20 cd/m Image state display-referred Percentages Allowed for R, G and B Percent reference range for R,G,B: 0% = 0.0, 100% = 1.0 let sign = c < 0? -1 : 1; let abs = Math.abs(c); if (abs < 0.04045) { cl = c / 12.92; } else { cl = sign * (Math.pow((abs + 0.055) / 1.055, 2.4)); } c is the gamma-encoded red, green or blue component. cl is the corresponding linear-light component. Visualization of the sRGB color space in LCH. The primaries and secondaries are shown.",
                "type": "value",
                "value": "srgb"
            },
            {
                "name": "srgb-linear",
                "prose": "The srgb-linear [SRGB] color space accepts three numeric parameters, representing the red, green, and blue channels of the color. In-gamut colors have all three components in the range [0, 1]. The whitepoint is D65. It has the following characteristics: x y Red chromaticity 0.640 0.330 Green chromaticity 0.300 0.600 Blue chromaticity 0.150 0.060 White chromaticity D65 Transfer function unity, see below White luminance 80.0 cd/m Black luminance 0.20 cd/m Image state display-referred Percentages Allowed for R, G and B Percent reference range for R,G,B: 0% = 0.0, 100% = 1.0 cl = c; c is the red, green or blue component. cl is the corresponding linear-light component, which is identical. To avoid banding artifacts, a higher precision is required for srgb-linear than for srgb. For example, these are the same color color(srgb 0.691 0.139 0.259) color(srgb-linear 0.435 0.017 0.055)",
                "type": "value",
                "value": "srgb-linear"
            },
            {
                "name": "display-p3",
                "prose": "The display-p3 [Display-P3] color space accepts three numeric parameters, representing the red, green, and blue channels of the color. In-gamut colors have all three components in the range [0, 1]. It uses the same primary chromaticities as [DCI-P3], but with a D65 whitepoint, and the same transfer curve as sRGB. Modern displays, TVs, laptop screens and phone screens are able to display all, or nearly all, of the display-p3 gamut. It has the following characteristics: x y Red chromaticity 0.680 0.320 Green chromaticity 0.265 0.690 Blue chromaticity 0.150 0.060 White chromaticity D65 Transfer function same as srgb White luminance 80.0 cd/m Black luminance 0.80 cd/m Image state display-referred Percentages Allowed for R, G and B Percent reference range for R,G,B: 0% = 0.0, 100% = 1.0 Visualization of the P3 color space in LCH. The primaries and secondaries are shown (but in sRGB, not in the correct colors). For comparison, the sRGB primaries and secondaries are also shown, as dashed circles. P3 primaries have higher Chroma.",
                "type": "value",
                "value": "display-p3"
            },
            {
                "name": "a98-rgb",
                "prose": "The a98-rgb color space accepts three numeric parameters, representing the red, green, and blue channels of the color. In-gamut colors have all three components in the range [0, 1]. The transfer curve is a gamma function, close to but not exactly 1/2.2. It has the following characteristics: x y Red chromaticity 0.6400 0.3300 Green chromaticity 0.2100 0.7100 Blue chromaticity 0.1500 0.0600 White chromaticity D65 Transfer function 256/563 White luminance 160.0 cd/m Black luminance 0.5557 cd/m Image state display-referred Percentages Allowed for R, G and B Percent reference range for R,G,B: 0% = 0.0, 100% = 1.0 Visualization of the A98 color space in LCH. The primaries and secondaries are shown (but in sRGB, not in the correct colors). For comparison, the sRGB primaries and secondaries are also shown, as dashed circles. a98 primaries have higher Chroma, especially the yellow, green and cyan.",
                "type": "value",
                "value": "a98-rgb"
            },
            {
                "name": "prophoto-rgb",
                "prose": "The prophoto-rgb color space accepts three numeric parameters, representing the red, green, and blue channels of the color. In-gamut colors have all three components in the range [0, 1]. The transfer curve is a gamma function with a value of 1/1.8, and a small linear portion near black. The white point is D50, the same as is used by CIE Lab. Thus, conversion to CIE Lab does not require the chromatic adaptation step. The ProPhoto RGB space uses hyper-saturated, non physically realizable primaries. These were chosen to allow a wide color gamut and in particular, to minimize hue shifts under tonal manipulation. It is often used in digital photography as a wide gamut color space for the archival version of photographic images. The prophoto-rgb color space allows CSS to specify colors that will match colors in such images having the same RGB values. The ProPhoto RGB space was originally developed by Kodak and is described in [Wolfe]. It was standardized by ISO as [ROMM],[ROMM-RGB]. The white luminance is given as a range, and the viewing flare (and thus, the black luminance) is 0.5% to 1.0% of this. It has the following characteristics: x y Red chromaticity 0.734699 0.265301 Green chromaticity 0.159597 0.840403 Blue chromaticity 0.036598 0.000105 White chromaticity D50 Transfer function see below White luminance 160.0 to 640.0 cd/m Black luminance See text Image state display-referred Percentages Allowed for R, G and B Percent reference range for R,G,B: 0% = 0.0, 100% = 1.0 const E = 16/512; let sign = c < 0? -1 : 1; let abs = Math.abs(c); if (abs <= E) { cl = c / 16; } else { cl = sign * Math.pow(c, 1.8); } c is the gamma-encoded red, green or blue component. cl is the corresponding linear-light component. Visualization of the prophoto-rgb color space in LCH. The primaries and secondaries are shown (but in sRGB, not in the correct colors). For comparison, the sRGB primaries and secondaries are also shown, as dashed circles. prophoto-rgb primaries and secondaries have much higher Chroma, but much of this ultrawide gamut does not correspond to physically realizable colors.",
                "type": "value",
                "value": "prophoto-rgb"
            },
            {
                "name": "rec2020",
                "prose": "The rec2020 [Rec.2020] color space accepts three numeric parameters, representing the red, green, and blue channels of the color. In-gamut colors have all three components in the range [0, 1], (\"full-range\", in video terminology). ITU Reference 2020 is used for Ultra High Definition, 4k and 8k television. The primaries are physically realizable, but with difficulty as they lie very close to the spectral locus. Current displays are unable to reproduce the full gamut of rec2020. Coverage is expected to increase over time as displays improve. It has the following characteristics: x y Red chromaticity 0.708 0.292 Green chromaticity 0.170 0.797 Blue chromaticity 0.131 0.046 White chromaticity D65 Transfer function see below, from [Rec.2020] table 4 Image state display-referred Percentages Allowed for R, G and B Percent reference range for R,G,B: 0% = 0.0, 100% = 1.0 const α = 1.09929682680944 ; const β = 0.018053968510807; let sign = c < 0? -1 : 1; let abs = Math.abs(c); if (abs < β * 4.5 ) { cl = c / 4.5; } else { cl = sign * (Math.pow((abs + α -1 ) / α, 1/0.45)); } c is the gamma-encoded red, green or blue component. cl is the corresponding linear-light component. Visualization of the rec2020 color space in LCH. The primaries and secondaries are shown (but in sRGB, not in the correct colors). For comparison, the sRGB primaries and secondaries are also shown, as dashed circles. rec2020 primaries have much higher Chroma.",
                "type": "value",
                "value": "rec2020"
            },
            {
                "name": "xyz-d50",
                "prose": "The xyz color space accepts three numeric parameters, representing the X,Y and Z values. It represents the CIE XYZ [COLORIMETRY] color space, scaled such that diffuse white has a luminance (Y) of 1.0. and, if necessary, chromatically adapted to the reference white. The reference white for xyz-d50 is D50, while the reference white for xyz-d65 and xyz is D65. Values greater than 1.0/100% are allowed and must not be clamped; they represent colors brighter than diffuse white. Values less than 0/0% are uncommon, but can occur as a result of chromatic adaptation, and likewise must not be clamped. It has the following characteristics: Percentages Allowed for X,Y,Z Percent reference range for X,Y,Z: 0% = 0.0, 100% = 1.0 These are exactly equivalent: #7654CD rgb(46.27% 32.94% 80.39%) lab(44.36% 36.05 -58.99) color(xyz-d50 0.2005 0.14089 0.4472) color(xyz-d65 0.21661 0.14602 0.59452)",
                "type": "value",
                "value": "xyz-d50"
            },
            {
                "name": "xyz-d65",
                "prose": "The xyz color space accepts three numeric parameters, representing the X,Y and Z values. It represents the CIE XYZ [COLORIMETRY] color space, scaled such that diffuse white has a luminance (Y) of 1.0. and, if necessary, chromatically adapted to the reference white. The reference white for xyz-d50 is D50, while the reference white for xyz-d65 and xyz is D65. Values greater than 1.0/100% are allowed and must not be clamped; they represent colors brighter than diffuse white. Values less than 0/0% are uncommon, but can occur as a result of chromatic adaptation, and likewise must not be clamped. It has the following characteristics: Percentages Allowed for X,Y,Z Percent reference range for X,Y,Z: 0% = 0.0, 100% = 1.0 These are exactly equivalent: #7654CD rgb(46.27% 32.94% 80.39%) lab(44.36% 36.05 -58.99) color(xyz-d50 0.2005 0.14089 0.4472) color(xyz-d65 0.21661 0.14602 0.59452)",
                "type": "value",
                "value": "xyz-d65"
            },
            {
                "name": "xyz",
                "prose": "The xyz color space accepts three numeric parameters, representing the X,Y and Z values. It represents the CIE XYZ [COLORIMETRY] color space, scaled such that diffuse white has a luminance (Y) of 1.0. and, if necessary, chromatically adapted to the reference white. The reference white for xyz-d50 is D50, while the reference white for xyz-d65 and xyz is D65. Values greater than 1.0/100% are allowed and must not be clamped; they represent colors brighter than diffuse white. Values less than 0/0% are uncommon, but can occur as a result of chromatic adaptation, and likewise must not be clamped. It has the following characteristics: Percentages Allowed for X,Y,Z Percent reference range for X,Y,Z: 0% = 0.0, 100% = 1.0 These are exactly equivalent: #7654CD rgb(46.27% 32.94% 80.39%) lab(44.36% 36.05 -58.99) color(xyz-d50 0.2005 0.14089 0.4472) color(xyz-d65 0.21661 0.14602 0.59452)",
                "type": "value",
                "value": "xyz"
            }
        ]
    },
    "<colorspace-params>": {
        "name": "<colorspace-params>",
        "type": "type",
        "value": "[ <predefined-rgb-params> | <xyz-params>]"
    },
    "<custom-params>": {
        "name": "<custom-params>",
        "type": "type",
        "value": "<dashed-ident> [ <number> | <percentage> | none ]#"
    },
    "<predefined-rgb-params>": {
        "name": "<predefined-rgb-params>",
        "type": "type",
        "value": "<predefined-rgb> [ <number> | <percentage> | none ]{3}"
    },
    "<predefined-rgb>": {
        "name": "<predefined-rgb>",
        "type": "type",
        "value": "srgb | srgb-linear | display-p3 | a98-rgb | prophoto-rgb | rec2020"
    },
    "<xyz-params>": {
        "name": "<xyz-params>",
        "type": "type",
        "value": "<xyz-space> [ <number> | <percentage> | none ]{3}"
    },
    "<xyz>": {
        "name": "<xyz>",
        "type": "type",
        "value": "xyz | xyz-d50 | xyz-d65"
    },
    "device-cmyk()": {
        "name": "device-cmyk()",
        "type": "function",
        "value": "device-cmyk( <cmyk-component>{4} [ / <alpha-value> ]? )"
    },
    "<cmyk-component>": {
        "name": "<cmyk-component>",
        "type": "type",
        "value": "<number> | <percentage>"
    },
    "<color-space>": {
        "name": "<color-space>",
        "type": "type",
        "value": "<rectangular-color-space> | <polar-color-space>"
    },
    "<rectangular-color-space>": {
        "name": "<rectangular-color-space>",
        "type": "type",
        "value": "srgb | srgb-linear | display-p3 | a98-rgb | prophoto-rgb | rec2020 | lab | oklab | xyz | xyz-d50 | xyz-d65"
    },
    "<polar-color-space>": {
        "name": "<polar-color-space>",
        "type": "type",
        "value": "hsl | hwb | lch | oklch"
    },
    "<custom-color-space>": {
        "name": "<custom-color-space>",
        "type": "type",
        "value": "<dashed-ident>"
    },
    "<hue-interpolation-method>": {
        "name": "<hue-interpolation-method>",
        "type": "type",
        "value": "[ shorter | longer | increasing | decreasing ] hue"
    },
    "<color-interpolation-method>": {
        "name": "<color-interpolation-method>",
        "type": "type",
        "value": "in [ <rectangular-color-space> | <polar-color-space> <hue-interpolation-method>? ]"
    },
    "contrast-color()": {
        "name": "contrast-color()",
        "prose": "The contrast-color() functional notation identifies a sufficiently contrasting color against a specified background or foreground color without requiring manual computation.",
        "type": "function",
        "value": "contrast-color( [ [ <color> && [ tbd-fg | tbd-bg ] && <target-contrast>? ] | [ <color> && [ tbd-fg | tbd-bg ] && <target-contrast>, <color># ] ] )",
        "values": [
            {
                "name": "text",
                "prose": "The tbd-fg and tbd-bg keywords indicate the role of the base color in calculating the contrast: as text against a list of candidate background colors (text) or as a background against a list of candidate text colors. (The effective contrast of a pair of colors depends on their usage.)",
                "type": "value",
                "value": "text"
            },
            {
                "name": "wcag2",
                "prose": "The wcag2 keyword and wcag2() functional notations indicate use of the [WCAG21] luminance contrast algorithm. Their syntax is:",
                "type": "value",
                "value": "wcag2"
            },
            {
                "name": "wcag2()",
                "prose": "The wcag2 keyword and wcag2() functional notations indicate use of the [WCAG21] luminance contrast algorithm. Their syntax is:",
                "type": "function"
            }
        ]
    },
    "<target-contrast>": {
        "name": "<target-contrast>",
        "prose": "The <target-contrast> argument specifies the contrast algorithm(s) to use. If no color candidates have been provided, <target-contrast> may be omitted, in which case a UA-chosen algorithm is used.",
        "type": "type",
        "value": "<wcag2>"
    },
    "<wcag2>": {
        "name": "<wcag2>",
        "type": "type",
        "value": "wcag2 | wcag2([<number> | [ aa | aaa ] && large? ])"
    },
    "<alpha-value>": {
        "name": "<alpha-value>",
        "type": "type",
        "value": "<number> | <percentage>"
    },
    "<hue>": {
        "name": "<hue>",
        "type": "type",
        "value": "<number> | <angle>"
    },
    "rgb()": {
        "name": "rgb()",
        "type": "function",
        "value": "[ <legacy-rgb-syntax> | <modern-rgb-syntax> ]"
    },
    "rgba()": {
        "name": "rgba()",
        "type": "function",
        "value": "[ <legacy-rgba-syntax> | <modern-rgba-syntax> ]"
    },
    "<legacy-rgb-syntax>": {
        "name": "<legacy-rgb-syntax>",
        "type": "type",
        "value": "rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
    },
    "<legacy-rgba-syntax>": {
        "name": "<legacy-rgba-syntax>",
        "type": "type",
        "value": "rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
    },
    "<hex-color>": {
        "name": "<hex-color>",
        "prose": "The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits. In other words, a hex color is written as a hash character, \"#\", followed by some number of digits 0-9 or letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).",
        "type": "type"
    },
    "<named-color>": {
        "name": "<named-color>",
        "prose": "CSS defines a large set of named colors, so that common colors can be written and read more easily. A <named-color> is written as an <ident>, accepted anywhere a <color> is. As usual for CSS-defined <ident>s, all of these keywords are ASCII case-insensitive.",
        "type": "type"
    },
    "<system-color>": {
        "name": "<system-color>",
        "prose": "However, in forced colors mode, most colors on the page are forced into a restricted, user-chosen palette. The <system-color> keywords expose these user-chosen colors so that the rest of the page can integrate with this restricted palette.",
        "type": "type",
        "values": [
            {
                "name": "Canvas",
                "prose": "Background of application content or documents.",
                "type": "value",
                "value": "Canvas"
            },
            {
                "name": "CanvasText",
                "prose": "Text in application content or documents.",
                "type": "value",
                "value": "CanvasText"
            },
            {
                "name": "LinkText",
                "prose": "Text in non-active, non-visited links. For light backgrounds, traditionally blue.",
                "type": "value",
                "value": "LinkText"
            },
            {
                "name": "VisitedText",
                "prose": "Text in visited links. For light backgrounds, traditionally purple.",
                "type": "value",
                "value": "VisitedText"
            },
            {
                "name": "ActiveText",
                "prose": "Text in active links. For light backgrounds, traditionally red.",
                "type": "value",
                "value": "ActiveText"
            },
            {
                "name": "ButtonFace",
                "prose": "The face background color for push buttons.",
                "type": "value",
                "value": "ButtonFace"
            },
            {
                "name": "ButtonText",
                "prose": "Text on push buttons.",
                "type": "value",
                "value": "ButtonText"
            },
            {
                "name": "ButtonBorder",
                "prose": "The base border color for push buttons.",
                "type": "value",
                "value": "ButtonBorder"
            },
            {
                "name": "Field",
                "prose": "Background of input fields.",
                "type": "value",
                "value": "Field"
            },
            {
                "name": "FieldText",
                "prose": "Text in input fields.",
                "type": "value",
                "value": "FieldText"
            },
            {
                "name": "Highlight",
                "prose": "Background of selected text, for example from ::selection.",
                "type": "value",
                "value": "Highlight"
            },
            {
                "name": "HighlightText",
                "prose": "Text of selected text.",
                "type": "value",
                "value": "HighlightText"
            },
            {
                "name": "SelectedItem",
                "prose": "Background of selected items, for example a selected checkbox.",
                "type": "value",
                "value": "SelectedItem"
            },
            {
                "name": "SelectedItemText",
                "prose": "Text of selected items.",
                "type": "value",
                "value": "SelectedItemText"
            },
            {
                "name": "Mark",
                "prose": "Background of text that has been specially marked (such as by the HTML mark element).",
                "type": "value",
                "value": "Mark"
            },
            {
                "name": "MarkText",
                "prose": "Text that has been specially marked (such as by the HTML mark element).",
                "type": "value",
                "value": "MarkText"
            },
            {
                "name": "GrayText",
                "prose": "Disabled text. (Often, but not necessarily, gray.)",
                "type": "value",
                "value": "GrayText"
            },
            {
                "name": "AccentColor",
                "prose": "Background of accented user interface controls.",
                "type": "value",
                "value": "AccentColor"
            },
            {
                "name": "AccentColorText",
                "prose": "Text of accented user interface controls.",
                "type": "value",
                "value": "AccentColorText"
            }
        ]
    },
    "hsl()": {
        "name": "hsl()",
        "type": "function",
        "value": "[ <legacy-hsl-syntax> | <modern-hsl-syntax> ]",
        "values": [
            {
                "name": "HSL",
                "prose": "HSL colors are specified as a triplet of hue, saturation, and lightness. The syntax of the hsl() and hsla() functions is:",
                "type": "value",
                "value": "HSL"
            }
        ]
    },
    "hsla()": {
        "name": "hsla()",
        "type": "function",
        "value": "[ <legacy-hsla-syntax> | <modern-hsla-syntax> ]"
    },
    "<legacy-hsl-syntax>": {
        "name": "<legacy-hsl-syntax>",
        "type": "type",
        "value": "hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    "<legacy-hsla-syntax>": {
        "name": "<legacy-hsla-syntax>",
        "type": "type",
        "value": "hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
    },
    "<xyz-space>": {
        "name": "<xyz-space>",
        "type": "type",
        "value": "xyz | xyz-d50 | xyz-d65"
    },
    "<deprecated-color>": {
        "name": "<deprecated-color>",
        "prose": "The deprecated system colors are represented as the <deprecated-color> sub-type, and are defined as:",
        "type": "type"
    },
    "<quirky-color>": {
        "name": "<quirky-color>",
        "prose": "When CSS is being parsed in quirks mode, <quirky-color> is a type of <color> that is only valid in certain properties:",
        "type": "type"
    },
    "<supports-feature>": {
        "name": "<supports-feature>",
        "type": "type",
        "value": "<supports-decl>"
    },
    "<supports-selector-fn>": {
        "name": "<supports-selector-fn>",
        "type": "type",
        "value": "selector( <complex-selector> )"
    },
    "<supports-font-tech-fn>": {
        "name": "<supports-font-tech-fn>",
        "type": "type",
        "value": "font-tech( <font-tech> )"
    },
    "<supports-font-format-fn>": {
        "name": "<supports-font-format-fn>",
        "type": "type",
        "value": "font-format( <font-format> )"
    },
    "media()": {
        "name": "media()",
        "type": "function",
        "value": "media( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
    },
    "supports()": {
        "name": "supports()",
        "type": "function",
        "value": "supports( <declaration> )"
    },
    "<supports-condition>": {
        "name": "<supports-condition>",
        "type": "type",
        "value": "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
    },
    "<supports-in-parens>": {
        "name": "<supports-in-parens>",
        "type": "type",
        "value": "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
    },
    "<supports-decl>": {
        "name": "<supports-decl>",
        "type": "type",
        "value": "( <declaration> )"
    },
    "<container-condition>": {
        "name": "<container-condition>",
        "type": "type",
        "value": "[ <container-name> ]? <container-query>"
    },
    "<container-name>": {
        "name": "<container-name>",
        "type": "type",
        "value": "<custom-ident>"
    },
    "<container-query>": {
        "name": "<container-query>",
        "type": "type",
        "value": "not <query-in-parens> | <query-in-parens> [ [ and <query-in-parens> ]* | [ or <query-in-parens> ]* ]"
    },
    "<query-in-parens>": {
        "name": "<query-in-parens>",
        "type": "type",
        "value": "( <container-query> ) | ( <size-feature> ) | style( <style-query> ) | <general-enclosed>"
    },
    "<style-query>": {
        "name": "<style-query>",
        "type": "type",
        "value": "not <style-in-parens> | <style-in-parens> [ [ and <style-in-parens> ]* | [ or <style-in-parens> ]* ] | <style-feature>"
    },
    "<style-in-parens>": {
        "name": "<style-in-parens>",
        "type": "type",
        "value": "( <style-query> ) | ( <style-feature> ) | <general-enclosed>"
    },
    "<size-feature>": {
        "name": "<size-feature>",
        "prose": "A container size query allows querying the size of the query container’s principal box. It is a boolean combination of individual size features (<size-feature>) that each query a single, specific dimensional feature of the query container. The syntax of a <size-feature> is the same as for a media feature: a feature name, a comparator, and a value. [mediaqueries-5] The boolean syntax and logic combining size features into a size query is the same as for CSS feature queries. (See @supports. [CSS-CONDITIONAL-3])",
        "type": "type"
    },
    "<style-feature>": {
        "name": "<style-feature>",
        "prose": "A container style query allows querying the computed values of the query container. It is a boolean combination of individual style features (<style-feature>) that each query a single, specific property of the query container. The syntax of a <style-feature> is the same as for a declaration [CSS-SYNTAX-3], and its query is true if the computed value of the given property on the query container matches the given value (which is also computed with respect to the query container), unknown if the property or its value is invalid or unsupported, and false otherwise. The boolean syntax and logic combining style features into a style query is the same as for CSS feature queries. (See @supports. [CSS-CONDITIONAL-3])",
        "type": "type"
    },
    "<quote>": {
        "name": "<quote>",
        "type": "type",
        "value": "open-quote | close-quote | no-open-quote | no-close-quote",
        "values": [
            {
                "name": "open-quote",
                "prose": "These values are replaced by the appropriate string from the quotes property, and increments (decrements) the level of nesting for quotes. See § 2.4.1 Specifying quotes with the quotes property for more information.",
                "type": "value",
                "value": "open-quote"
            },
            {
                "name": "close-quote",
                "prose": "These values are replaced by the appropriate string from the quotes property, and increments (decrements) the level of nesting for quotes. See § 2.4.1 Specifying quotes with the quotes property for more information.",
                "type": "value",
                "value": "close-quote"
            },
            {
                "name": "no-open-quote",
                "prose": "Inserts nothing (as in none), but increments (decrements) the level of nesting for quotes. See § 2.4.1 Specifying quotes with the quotes property for more information.",
                "type": "value",
                "value": "no-open-quote"
            },
            {
                "name": "no-close-quote",
                "prose": "Inserts nothing (as in none), but increments (decrements) the level of nesting for quotes. See § 2.4.1 Specifying quotes with the quotes property for more information.",
                "type": "value",
                "value": "no-close-quote"
            }
        ]
    },
    "leader()": {
        "name": "leader()",
        "type": "function",
        "value": "leader( <leader-type> )",
        "values": [
            {
                "name": "dotted",
                "prose": "Equivalent to leader(\".\")",
                "type": "value",
                "value": "dotted"
            },
            {
                "name": "solid",
                "prose": "Equivalent to leader(\"_\")",
                "type": "value",
                "value": "solid"
            },
            {
                "name": "space",
                "prose": "Equivalent to leader(\" \")",
                "type": "value",
                "value": "space"
            },
            {
                "name": "<string>",
                "prose": "Issue: Define this.",
                "type": "value",
                "value": "<string>"
            }
        ]
    },
    "<leader-type>": {
        "name": "<leader-type>",
        "type": "type",
        "value": "dotted | solid | space | <string>"
    },
    "<target>": {
        "name": "<target>",
        "type": "type",
        "value": "<target-counter()> | <target-counters()> | <target-text()>"
    },
    "target-counter()": {
        "name": "target-counter()",
        "type": "function",
        "value": "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
    },
    "target-counters()": {
        "name": "target-counters()",
        "type": "function",
        "value": "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
    },
    "target-text()": {
        "name": "target-text()",
        "type": "function",
        "value": "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
    },
    "string()": {
        "name": "string()",
        "type": "function",
        "value": "string( <custom-ident> , [ first | start | last | first-except ]? )",
        "values": [
            {
                "name": "first",
                "prose": "The value of the first assignment on the page is used. If there is no assignment on the page, the entry value is used. If no second argument is provided, this is the default value.",
                "type": "value",
                "value": "first"
            },
            {
                "name": "start",
                "prose": "If the element is the first element on the page, the value of the first assignment is used. Otherwise the entry value is used. The entry value may be empty if the named string hasn’t yet appeared.",
                "type": "value",
                "value": "start"
            },
            {
                "name": "last",
                "prose": "The exit value of the named string is used.",
                "type": "value",
                "value": "last"
            },
            {
                "name": "first-except",
                "prose": "This is identical to first, except that the empty string is used on the page where the value is assigned. we may need to kill the entire content string. Is this necessary?",
                "type": "value",
                "value": "first-except"
            }
        ]
    },
    "content()": {
        "name": "content()",
        "type": "function",
        "value": "content( [ text | before | after | first-letter | marker ]? )",
        "values": [
            {
                "name": "text",
                "prose": "The string value of the element. If no value is specified in content(), it acts as if text were specified.",
                "type": "value",
                "value": "text"
            },
            {
                "name": "before",
                "prose": "The string value of the ::before pseudo-element.",
                "type": "value",
                "value": "before"
            },
            {
                "name": "after",
                "prose": "The string value of the ::after pseudo-element.",
                "type": "value",
                "value": "after"
            },
            {
                "name": "first-letter",
                "prose": "The first letter of the element, as defined for the ::first-letter pseudo-element",
                "type": "value",
                "value": "first-letter"
            },
            {
                "name": "marker",
                "prose": "The string value of the ::marker pseudo-element.",
                "type": "value",
                "value": "marker"
            }
        ]
    },
    "<counter-style-name>": {
        "name": "<counter-style-name>",
        "prose": "<counter-style-name> is a <custom-ident> that is not an ASCII case-insensitive match for none. The <counter-style-name> is a tree-scoped name.",
        "type": "type",
        "values": [
            {
                "name": "decimal",
                "prose": "Western decimal numbers (e.g., 1, 2, 3, ..., 98, 99, 100).",
                "type": "value",
                "value": "decimal"
            },
            {
                "name": "decimal-leading-zero",
                "prose": "Decimal numbers padded by initial zeros (e.g., 01, 02, 03, ..., 98, 99, 100).",
                "type": "value",
                "value": "decimal-leading-zero"
            },
            {
                "name": "arabic-indic",
                "prose": "Arabic-indic numbering (e.g., ١‎, ٢‎, ٣‎, ٤‎, ..., ٩٨‎, ٩٩‎, ١٠٠‎).",
                "type": "value",
                "value": "arabic-indic"
            },
            {
                "name": "armenian",
                "prose": "Traditional uppercase Armenian numbering (e.g., Ա, Բ, Գ, ..., ՂԸ, ՂԹ, Ճ).",
                "type": "value",
                "value": "armenian"
            },
            {
                "name": "upper-armenian",
                "prose": "Traditional uppercase Armenian numbering (e.g., Ա, Բ, Գ, ..., ՂԸ, ՂԹ, Ճ).",
                "type": "value",
                "value": "upper-armenian"
            },
            {
                "name": "lower-armenian",
                "prose": "Lowercase Armenian numbering (e.g., ա, բ, գ, ..., ղը, ղթ, ճ).",
                "type": "value",
                "value": "lower-armenian"
            },
            {
                "name": "bengali",
                "prose": "Bengali numbering (e.g., ১, ২, ৩, ..., ৯৮, ৯৯, ১০০).",
                "type": "value",
                "value": "bengali"
            },
            {
                "name": "cambodian",
                "prose": "Cambodian/Khmer numbering (e.g., ១, ២, ៣, ..., ៩៨, ៩៩, ១០០).",
                "type": "value",
                "value": "cambodian"
            },
            {
                "name": "khmer",
                "prose": "Cambodian/Khmer numbering (e.g., ១, ២, ៣, ..., ៩៨, ៩៩, ១០០).",
                "type": "value",
                "value": "khmer"
            },
            {
                "name": "cjk-decimal",
                "prose": "Han decimal numbers (e.g., 一, 二, 三, ..., 九八, 九九, 一〇〇).",
                "type": "value",
                "value": "cjk-decimal"
            },
            {
                "name": "devanagari",
                "prose": "devanagari numbering (e.g., १, २, ३, ..., ९८, ९९, १००).",
                "type": "value",
                "value": "devanagari"
            },
            {
                "name": "georgian",
                "prose": "Traditional Georgian numbering (e.g., ა, ბ, გ, ..., ჟჱ, ჟთ, რ).",
                "type": "value",
                "value": "georgian"
            },
            {
                "name": "gujarati",
                "prose": "Gujarati numbering (e.g., ૧, ૨, ૩, ..., ૯૮, ૯૯, ૧૦૦).",
                "type": "value",
                "value": "gujarati"
            },
            {
                "name": "gurmukhi",
                "prose": "Gurmukhi numbering (e.g., ੧, ੨, ੩, ..., ੯੮, ੯੯, ੧੦੦).",
                "type": "value",
                "value": "gurmukhi"
            },
            {
                "name": "hebrew",
                "prose": "Traditional Hebrew numbering (e.g., א‎, ב‎, ג‎, ..., צח‎, צט‎, ק‎).",
                "type": "value",
                "value": "hebrew"
            },
            {
                "name": "kannada",
                "prose": "Kannada numbering (e.g., ೧, ೨, ೩, ..., ೯೮, ೯೯, ೧೦೦).",
                "type": "value",
                "value": "kannada"
            },
            {
                "name": "lao",
                "prose": "Laotian numbering (e.g., ໑, ໒, ໓, ..., ໙໘, ໙໙, ໑໐໐).",
                "type": "value",
                "value": "lao"
            },
            {
                "name": "malayalam",
                "prose": "Malayalam numbering (e.g., ൧, ൨, ൩, ..., ൯൮, ൯൯, ൧൦൦).",
                "type": "value",
                "value": "malayalam"
            },
            {
                "name": "mongolian",
                "prose": "Mongolian numbering (e.g., ᠑, ᠒, ᠓, ..., ᠙᠘, ᠙᠙, ᠑᠐᠐).",
                "type": "value",
                "value": "mongolian"
            },
            {
                "name": "myanmar",
                "prose": "Myanmar (Burmese) numbering (e.g., ၁, ၂, ၃, ..., ၉၈, ၉၉, ၁၀၀).",
                "type": "value",
                "value": "myanmar"
            },
            {
                "name": "oriya",
                "prose": "Oriya numbering (e.g., ୧, ୨, ୩, ..., ୯୮, ୯୯, ୧୦୦).",
                "type": "value",
                "value": "oriya"
            },
            {
                "name": "persian",
                "prose": "Persian numbering (e.g., ۱, ۲, ۳, ۴, ..., ۹۸, ۹۹, ۱۰۰).",
                "type": "value",
                "value": "persian"
            },
            {
                "name": "lower-roman",
                "prose": "Lowercase ASCII Roman numerals (e.g., i, ii, iii, ..., xcviii, xcix, c).",
                "type": "value",
                "value": "lower-roman"
            },
            {
                "name": "upper-roman",
                "prose": "Uppercase ASCII Roman numerals (e.g., I, II, III, ..., XCVIII, XCIX, C).",
                "type": "value",
                "value": "upper-roman"
            },
            {
                "name": "tamil",
                "prose": "Tamil numbering (e.g., ௧, ௨, ௩, ..., ௯௮, ௯௯, ௧௦௦).",
                "type": "value",
                "value": "tamil"
            },
            {
                "name": "telugu",
                "prose": "Telugu numbering (e.g., ౧, ౨, ౩, ..., ౯౮, ౯౯, ౧౦౦).",
                "type": "value",
                "value": "telugu"
            },
            {
                "name": "thai",
                "prose": "Thai (Siamese) numbering (e.g., ๑, ๒, ๓, ..., ๙๘, ๙๙, ๑๐๐).",
                "type": "value",
                "value": "thai"
            },
            {
                "name": "tibetan",
                "prose": "Tibetan numbering (e.g., ༡, ༢, ༣, ..., ༩༨, ༩༩, ༡༠༠).",
                "type": "value",
                "value": "tibetan"
            },
            {
                "name": "lower-alpha",
                "prose": "Lowercase ASCII letters (e.g., a, b, c, ..., z, aa, ab).",
                "type": "value",
                "value": "lower-alpha"
            },
            {
                "name": "lower-latin",
                "prose": "Lowercase ASCII letters (e.g., a, b, c, ..., z, aa, ab).",
                "type": "value",
                "value": "lower-latin"
            },
            {
                "name": "upper-alpha",
                "prose": "Uppercase ASCII letters (e.g., A, B, C, ..., Z, AA, AB).",
                "type": "value",
                "value": "upper-alpha"
            },
            {
                "name": "upper-latin",
                "prose": "Uppercase ASCII letters (e.g., A, B, C, ..., Z, AA, AB).",
                "type": "value",
                "value": "upper-latin"
            },
            {
                "name": "lower-greek",
                "prose": "Lowercase classical Greek (e.g., α, β, γ, ..., ω, αα, αβ).",
                "type": "value",
                "value": "lower-greek"
            },
            {
                "name": "hiragana",
                "prose": "Dictionary-order hiragana lettering (e.g., あ, い, う, ..., ん, ああ, あい).",
                "type": "value",
                "value": "hiragana"
            },
            {
                "name": "hiragana-iroha",
                "prose": "Iroha-order hiragana lettering (e.g., い, ろ, は, ..., す, いい, いろ).",
                "type": "value",
                "value": "hiragana-iroha"
            },
            {
                "name": "katakana",
                "prose": "Dictionary-order katakana lettering (e.g., ア, イ, ウ, ..., ン, アア, アイ).",
                "type": "value",
                "value": "katakana"
            },
            {
                "name": "katakana-iroha",
                "prose": "Iroha-order katakana lettering (e.g., イ, ロ, ハ, ..., ス, イイ, イロ)",
                "type": "value",
                "value": "katakana-iroha"
            },
            {
                "name": "disc",
                "prose": "A filled circle, similar to • U+2022 BULLET.",
                "type": "value",
                "value": "disc"
            },
            {
                "name": "circle",
                "prose": "A hollow circle, similar to ◦ U+25E6 WHITE BULLET.",
                "type": "value",
                "value": "circle"
            },
            {
                "name": "square",
                "prose": "A filled square, similar to ▪ U+25AA BLACK SMALL SQUARE.",
                "type": "value",
                "value": "square"
            },
            {
                "name": "disclosure-open",
                "prose": "Symbols appropriate for indicating an open or closed disclosure widget, such as the HTML details element.",
                "type": "value",
                "value": "disclosure-open"
            },
            {
                "name": "disclosure-closed",
                "prose": "Symbols appropriate for indicating an open or closed disclosure widget, such as the HTML details element.",
                "type": "value",
                "value": "disclosure-closed"
            },
            {
                "name": "cjk-earthly-branch",
                "prose": "Han \"Earthly Branch\" ordinals (e.g., 子, 丑, 寅, ..., 亥).",
                "type": "value",
                "value": "cjk-earthly-branch"
            },
            {
                "name": "cjk-heavenly-stem",
                "prose": "Han \"Heavenly Stem\" ordinals (e.g., 甲, 乙, 丙, ..., 癸)",
                "type": "value",
                "value": "cjk-heavenly-stem"
            },
            {
                "name": "korean-hangul-formal",
                "prose": "Korean Hangul numbering (e.g., 일천일백일십일)",
                "type": "value",
                "value": "korean-hangul-formal"
            },
            {
                "name": "korean-hanja-informal",
                "prose": "Informal Korean Hanja numbering (e.g., 千百十一)",
                "type": "value",
                "value": "korean-hanja-informal"
            },
            {
                "name": "korean-hanja-formal",
                "prose": "Formal Korean Han (Hanja) numbering (e.g., 壹仟壹百壹拾壹)",
                "type": "value",
                "value": "korean-hanja-formal"
            },
            {
                "name": "ethiopic-numeric",
                "prose": "The ethiopic-numeric counter style is defined for all positive non-zero numbers. The following algorithm converts decimal digits to ethiopic numbers:",
                "type": "value",
                "value": "ethiopic-numeric"
            }
        ]
    },
    "<symbol>": {
        "name": "<symbol>",
        "type": "type",
        "value": "<string> | <image> | <custom-ident>"
    },
    "symbols()": {
        "name": "symbols()",
        "type": "function",
        "value": "symbols( <symbols-type>? [ <string> | <image> ]+ )"
    },
    "<symbols-type>": {
        "name": "<symbols-type>",
        "type": "type",
        "value": "cyclic | numeric | alphabetic | symbolic | fixed"
    },
    "<counter-style>": {
        "name": "<counter-style>",
        "type": "type",
        "value": "<counter-style-name> | <symbols()>",
        "values": [
            {
                "name": "japanese-informal",
                "prose": "Informal Japanese Kanji numbering (e.g., 千百十一)",
                "type": "value",
                "value": "japanese-informal"
            },
            {
                "name": "japanese-formal",
                "prose": "Formal Japanese Kanji numbering (e.g. 壱阡壱百壱拾壱)",
                "type": "value",
                "value": "japanese-formal"
            },
            {
                "name": "simp-chinese-informal",
                "prose": "Simplified Chinese informal numbering (e.g., 一千一百一十一)",
                "type": "value",
                "value": "simp-chinese-informal"
            },
            {
                "name": "simp-chinese-formal",
                "prose": "Simplified Chinese formal numbering (e.g. 壹仟壹佰壹拾壹)",
                "type": "value",
                "value": "simp-chinese-formal"
            },
            {
                "name": "trad-chinese-informal",
                "prose": "Traditional Chinese informal numbering (e.g., 一千一百一十一)",
                "type": "value",
                "value": "trad-chinese-informal"
            },
            {
                "name": "trad-chinese-formal",
                "prose": "Traditional Chinese formal numbering (e.g., 壹仟壹佰壹拾壹)",
                "type": "value",
                "value": "trad-chinese-formal"
            },
            {
                "name": "cjk-ideographic",
                "prose": "This counter style is identical to trad-chinese-informal. (It exists for legacy reasons.)",
                "type": "value",
                "value": "cjk-ideographic"
            }
        ]
    },
    "<display-outside>": {
        "name": "<display-outside>",
        "type": "type",
        "value": "block | inline | run-in",
        "values": [
            {
                "name": "block",
                "prose": "The element generates a box that is block-level when placed in flow layout. [CSS2]",
                "type": "value",
                "value": "block"
            },
            {
                "name": "inline",
                "prose": "The element generates a box that is inline-level when placed in flow layout. [CSS2]",
                "type": "value",
                "value": "inline"
            },
            {
                "name": "run-in",
                "prose": "The element generates an run-in box, which is a type of inline-level box with special behavior that attempts to merge it into a subsequent block container. See § 5 Run-In Layout for details.",
                "type": "value",
                "value": "run-in"
            }
        ]
    },
    "<display-inside>": {
        "name": "<display-inside>",
        "type": "type",
        "value": "flow | flow-root | table | flex | grid | ruby",
        "values": [
            {
                "name": "flow",
                "prose": "The element lays out its contents using flow layout (block-and-inline layout). If its outer display type is inline or run-in, and it is participating in a block or inline formatting context, then it generates an inline box. Otherwise it generates a block container box. Depending on the value of other properties (such as position, float, or overflow) and whether it is itself participating in a block or inline formatting context, it either establishes a new block formatting context for its contents or integrates its contents into its parent formatting context. See CSS2.1 Chapter 9. [CSS2] A block container that establishes a new block formatting context is considered to have a used inner display type of flow-root.",
                "type": "value",
                "value": "flow"
            },
            {
                "name": "flow-root",
                "prose": "The element generates a block container box, and lays out its contents using flow layout. It always establishes a new block formatting context for its contents. [CSS2]",
                "type": "value",
                "value": "flow-root"
            },
            {
                "name": "table",
                "prose": "The element generates a principal table wrapper box that establishes a block formatting context, and which contains an additionally-generated table grid box that establishes a table formatting context. [CSS2]",
                "type": "value",
                "value": "table"
            },
            {
                "name": "flex",
                "prose": "The element generates a principal flex container box and establishes a flex formatting context. [CSS-FLEXBOX-1]",
                "type": "value",
                "value": "flex"
            },
            {
                "name": "grid",
                "prose": "The element generates a principal grid container box, and establishes a grid formatting context. [CSS-GRID-1] (Grids using subgrid might not generate a new grid formatting context; see [CSS-GRID-2] for details.)",
                "type": "value",
                "value": "grid"
            },
            {
                "name": "ruby",
                "prose": "The element generates a ruby container box and establishes a ruby formatting context in addition to integrating its base-level contents into its parent formatting context (if it is inline) or generating a wrapper box of the appropriate outer display type (if it is not). [CSS-RUBY-1]",
                "type": "value",
                "value": "ruby"
            }
        ]
    },
    "<display-listitem>": {
        "name": "<display-listitem>",
        "type": "type",
        "value": "<display-outside>? && [ flow | flow-root ]? && list-item"
    },
    "<display-internal>": {
        "name": "<display-internal>",
        "type": "type",
        "value": "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container",
        "values": [
            {
                "name": "table-row-group",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-row-group"
            },
            {
                "name": "table-header-group",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-header-group"
            },
            {
                "name": "table-footer-group",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-footer-group"
            },
            {
                "name": "table-row",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-row"
            },
            {
                "name": "table-cell",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-cell"
            },
            {
                "name": "table-column-group",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-column-group"
            },
            {
                "name": "table-column",
                "prose": "The element is an internal table element. It generates the appropriate internal table box which participates in a table formatting context. See CSS2§17.2 [CSS2]. table-cell boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-column"
            },
            {
                "name": "table-caption",
                "prose": "The element generates a table caption box, which is a block box with special behavior with respect to table and table wrapper boxes. See CSS2§17.2 [CSS2]. table-caption boxes have a flow-root inner display type.",
                "type": "value",
                "value": "table-caption"
            },
            {
                "name": "ruby-base",
                "prose": "The element is an internal ruby element. It generates the appropriate internal ruby box which participates in a ruby formatting context. [CSS-RUBY-1] ruby-base and ruby-text have a flow inner display type.",
                "type": "value",
                "value": "ruby-base"
            },
            {
                "name": "ruby-text",
                "prose": "The element is an internal ruby element. It generates the appropriate internal ruby box which participates in a ruby formatting context. [CSS-RUBY-1] ruby-base and ruby-text have a flow inner display type.",
                "type": "value",
                "value": "ruby-text"
            },
            {
                "name": "ruby-base-container",
                "prose": "The element is an internal ruby element. It generates the appropriate internal ruby box which participates in a ruby formatting context. [CSS-RUBY-1] ruby-base and ruby-text have a flow inner display type.",
                "type": "value",
                "value": "ruby-base-container"
            },
            {
                "name": "ruby-text-container",
                "prose": "The element is an internal ruby element. It generates the appropriate internal ruby box which participates in a ruby formatting context. [CSS-RUBY-1] ruby-base and ruby-text have a flow inner display type.",
                "type": "value",
                "value": "ruby-text-container"
            }
        ]
    },
    "<display-box>": {
        "name": "<display-box>",
        "type": "type",
        "value": "contents | none",
        "values": [
            {
                "name": "contents",
                "prose": "The element itself does not generate any boxes, but its children and pseudo-elements still generate boxes and text sequences as normal. For the purposes of box generation and layout, the element must be treated as if it had been replaced in the element tree by its contents (including both its source-document children and its pseudo-elements, such as ::before and ::after pseudo-elements, which are generated before/after the element’s children as normal). This value computes to display: none on replaced elements and other elements whose rendering is not entirely controlled by CSS; see Appendix B: Effects of display: contents on Unusual Elements for details.",
                "type": "value",
                "value": "contents"
            },
            {
                "name": "none",
                "prose": "The element and its descendants generate no boxes or text sequences. Similarly, if a text node is defined to behave as display: none, it generates no text sequences.",
                "type": "value",
                "value": "none"
            }
        ]
    },
    "<display-legacy>": {
        "name": "<display-legacy>",
        "type": "type",
        "value": "inline-block | inline-table | inline-flex | inline-grid",
        "values": [
            {
                "name": "inline-block",
                "prose": "Computes to inline flow-root.",
                "type": "value",
                "value": "inline-block"
            },
            {
                "name": "inline-table",
                "prose": "Computes to inline table.",
                "type": "value",
                "value": "inline-table"
            },
            {
                "name": "inline-flex",
                "prose": "Computes to inline flex.",
                "type": "value",
                "value": "inline-flex"
            },
            {
                "name": "inline-grid",
                "prose": "Computes to inline grid.",
                "type": "value",
                "value": "inline-grid"
            }
        ]
    },
    "<easing-function>": {
        "name": "<easing-function>",
        "value": "linear | <linear-easing-function> | <cubic-bezier-easing-function> | <step-easing-function>",
        "type": "type",
        "values": [
            {
                "name": "linear",
                "prose": "The linear keyword produces a linear easing function with two points:",
                "type": "value",
                "value": "linear"
            }
        ]
    },
    "<linear-easing-function>": {
        "name": "<linear-easing-function>",
        "type": "type",
        "value": "linear(<linear-stop-list>)"
    },
    "linear()": {
        "name": "linear()",
        "value": "linear(<linear-stop-list>)",
        "type": "function"
    },
    "<linear-stop-list>": {
        "name": "<linear-stop-list>",
        "type": "type",
        "value": "[ <linear-stop> ]#"
    },
    "<linear-stop>": {
        "name": "<linear-stop>",
        "type": "type",
        "value": "<number> && <linear-stop-length>?"
    },
    "<linear-stop-length>": {
        "name": "<linear-stop-length>",
        "type": "type",
        "value": "<percentage>{1,2}"
    },
    "<cubic-bezier-easing-function>": {
        "name": "<cubic-bezier-easing-function>",
        "value": "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)",
        "type": "type",
        "values": [
            {
                "name": "ease",
                "prose": "Equivalent to cubic-bezier(0.25, 0.1, 0.25, 1).",
                "type": "value",
                "value": "ease"
            },
            {
                "name": "ease-in",
                "prose": "Equivalent to cubic-bezier(0.42, 0, 1, 1).",
                "type": "value",
                "value": "ease-in"
            },
            {
                "name": "ease-out",
                "prose": "Equivalent to cubic-bezier(0, 0, 0.58, 1).",
                "type": "value",
                "value": "ease-out"
            },
            {
                "name": "ease-in-out",
                "prose": "Equivalent to cubic-bezier(0.42, 0, 0.58, 1).",
                "type": "value",
                "value": "ease-in-out"
            },
            {
                "name": "cubic-bezier()",
                "value": "cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)",
                "type": "function"
            }
        ]
    },
    "<step-easing-function>": {
        "name": "<step-easing-function>",
        "value": "step-start | step-end | steps(<integer>[, <step-position>]?)",
        "type": "type",
        "values": [
            {
                "name": "step-start",
                "prose": "Computes to steps(1, start)",
                "type": "value",
                "value": "step-start"
            },
            {
                "name": "step-end",
                "prose": "Computes to steps(1, end) Example step easing function keyword values.",
                "type": "value",
                "value": "step-end"
            },
            {
                "name": "steps()",
                "value": "steps(<integer>, <step-position>?)",
                "type": "function",
                "values": [
                    {
                        "name": "jump-start",
                        "prose": "The first rise occurs at input progress value of 0.",
                        "type": "value",
                        "value": "jump-start"
                    },
                    {
                        "name": "jump-end",
                        "prose": "The last rise occurs at input progress value of 1.",
                        "type": "value",
                        "value": "jump-end"
                    },
                    {
                        "name": "jump-none",
                        "prose": "All rises occur within the range (0, 1).",
                        "type": "value",
                        "value": "jump-none"
                    },
                    {
                        "name": "jump-both",
                        "prose": "The first rise occurs at input progress value of 0 and the last rise occurs at input progress value of 1.",
                        "type": "value",
                        "value": "jump-both"
                    },
                    {
                        "name": "start",
                        "prose": "Behaves as jump-start.",
                        "type": "value",
                        "value": "start"
                    },
                    {
                        "name": "end",
                        "prose": "Behaves as jump-end.",
                        "type": "value",
                        "value": "end"
                    }
                ]
            }
        ]
    },
    "<step-position>": {
        "name": "<step-position>",
        "value": "jump-start | jump-end | jump-none | jump-both | start | end",
        "type": "type"
    },
    "env()": {
        "name": "env()",
        "type": "function",
        "value": "env( <custom-ident> <integer [0,∞]>*, <declaration-value>? )",
        "values": [
            {
                "name": "safe-area-inset-top",
                "type": "value",
                "value": "safe-area-inset-top"
            },
            {
                "name": "safe-area-inset-right",
                "type": "value",
                "value": "safe-area-inset-right"
            },
            {
                "name": "safe-area-inset-bottom",
                "type": "value",
                "value": "safe-area-inset-bottom"
            },
            {
                "name": "safe-area-inset-left",
                "type": "value",
                "value": "safe-area-inset-left"
            },
            {
                "name": "viewport-segment-width",
                "type": "value",
                "value": "viewport-segment-width"
            },
            {
                "name": "viewport-segment-height",
                "type": "value",
                "value": "viewport-segment-height"
            },
            {
                "name": "viewport-segment-top",
                "type": "value",
                "value": "viewport-segment-top"
            },
            {
                "name": "viewport-segment-left",
                "type": "value",
                "value": "viewport-segment-left"
            },
            {
                "name": "viewport-segment-bottom",
                "type": "value",
                "value": "viewport-segment-bottom"
            },
            {
                "name": "viewport-segment-right",
                "type": "value",
                "value": "viewport-segment-right"
            }
        ]
    },
    "<extension-name>": {
        "name": "<extension-name>",
        "prose": "All extensions defined in this specification use a common syntax for defining their ”names”: the <extension-name> production. An <extension-name> is any identifier that starts with two dashes (U+002D HYPHEN-MINUS), like --foo, or even exotic names like -- or ------. The CSS language will never use identifiers of this form for any language-defined purpose, so it’s safe to use them for author-defined purposes without ever having to worry about colliding with CSS-defined names.",
        "type": "type"
    },
    "<custom-selector>": {
        "name": "<custom-selector>",
        "type": "type",
        "value": "<custom-arg>? : <extension-name> [ ( <custom-arg>+#? ) ]? ;"
    },
    "<custom-arg>": {
        "name": "<custom-arg>",
        "type": "type",
        "value": "$ <ident-token> ;"
    },
    "<font-format>": {
        "name": "<font-format>",
        "type": "type",
        "value": "[<string> | collection | embedded-opentype | opentype | svg | truetype | woff | woff2 ]"
    },
    "<font-tech>": {
        "name": "<font-tech>",
        "type": "type",
        "value": "[<font-features-tech> | <color-font-tech> | variations | palettes | incremental-patch | incremental-range | incremental-auto ]"
    },
    "<font-features-tech>": {
        "name": "<font-features-tech>",
        "type": "type",
        "value": "[features-opentype | features-aat | features-graphite]"
    },
    "<color-font-tech>": {
        "name": "<color-font-tech>",
        "type": "type",
        "value": "[color-COLRv0 | color-COLRv1 | color-SVG | color-sbix | color-CBDT ]"
    },
    "<family-name>": {
        "name": "<family-name>",
        "prose": "The name of a font family, such as Helvetica or Verdana in the previous example.",
        "type": "type"
    },
    "<generic-family>": {
        "name": "<generic-family>",
        "prose": "Each <generic-family> keyword represents a generic font choice, and behaves as an alias for one or more locally-installed fonts belonging to the specified generic font category. A <generic-family> can thus be used as a reliable fallback for when an author’s more specific font choices are not available. Authors are encouraged to append a generic font family as a last alternative for improved robustness. Note that <generic-family> keywords cannot be quoted (otherwise they are interpreted as a <family-name>). The set of generic family keywords is defined in § 2.1.3 Generic font families.",
        "type": "type",
        "values": [
            {
                "name": "serif",
                "prose": "Serif fonts represent the formal text style for a script. This often means, but is not limited to, glyphs that have finishing strokes, flared or tapering ends, or have actual serifed endings (including slab serifs). Serif fonts are typically proportionately-spaced. They often display a greater variation between thick and thin strokes than fonts from the sans-serif generic font family. CSS uses the term \"serif\" to apply to a font for any script, although other names might be more familiar for particular scripts, such as Mincho (Japanese), Sung or Song (Chinese), Batang (Korean). For Arabic, the Naskh style would correspond to serif. This is due to its typographic role, rather than its design style. Any font that fits this typographic role may be used to represent the generic serif family. serif must always map to at least one matched font face. Sample serif fonts",
                "type": "value",
                "value": "serif"
            },
            {
                "name": "sans-serif",
                "prose": "Glyphs in sans-serif fonts, as the term is used in CSS, are generally low contrast (vertical and horizontal stems have the close to the same thickness) and have stroke endings that are plain (without any flaring, cross stroke, or other ornamentation). Sans-serif fonts are typically proportionately-spaced. They often have little variation between thick and thin strokes, compared to fonts from the serif family. CSS uses the term \"sans-serif\" to apply to a font for any script, although other names might be more familiar for particular scripts, such as Gothic (Japanese), Hei (Chinese), or Gulim (Korean). Any font that fits this typographic role may be used to represent the generic sans-serif family. sans-serif must always map to at least one matched font face. Sample sans-serif fonts",
                "type": "value",
                "value": "sans-serif"
            },
            {
                "name": "cursive",
                "prose": "Glyphs in cursive fonts generally use a more informal script style, and the result looks more like handwritten pen or brush writing than printed letterwork. For example, Kaiti (Chinese), which uses a brush-based style, would be classified as a CSS cursive font family. CSS uses the term \"cursive\" to apply to a font for any script, although other names such as Chancery, Brush, Swing and Script are also used in font names. Sample cursive fonts",
                "type": "value",
                "value": "cursive"
            },
            {
                "name": "fantasy",
                "prose": "Fantasy fonts are primarily decorative or expressive fonts that contain decorative or expressive representations of characters. These do not include Pi or Picture fonts which do not represent actual characters. Sample fantasy fonts",
                "type": "value",
                "value": "fantasy"
            },
            {
                "name": "monospace",
                "prose": "The sole criterion of a monospace font is that all glyphs have the same fixed width. This is often used to render samples of computer code. monospace must always map to at least one matched font face. Sample monospace fonts",
                "type": "value",
                "value": "monospace"
            },
            {
                "name": "system-ui",
                "prose": "This generic font family lets text render with the default user interface font on the platform on which the UA is running. A cross-platform UA should use different fonts on its different supported platforms. The purpose of system-ui is to allow web content to integrate with the look and feel of the native OS. As with other generic font families, the substitution of specific installed fonts for system-ui does not affect the computed style. <div id=\"system-text\" style=\"font-family: system-ui\"></div> ... window.getComputedStyle(document.getElementById(\"system-text\")).getPropertyValue(\"font-family\"); The script above should not have any knowledge of how system-ui is expanded to include a collection of system user interface fonts. In particular, the above script should yield a result of \"system-ui\" on every platform.",
                "type": "value",
                "value": "system-ui"
            },
            {
                "name": "emoji",
                "prose": "This font family is intended for use with emoji characters. Emoji are pictographs (pictorial symbols) that are typically presented in a colorful form and used inline in text. They represent things such as faces, weather, vehicles and buildings, food and drink, animals and plants, or icons that represent emotions, feelings, or activities.",
                "type": "value",
                "value": "emoji"
            },
            {
                "name": "math",
                "prose": "This font family is intended for use with mathematical expressions. Such fonts may include additional data (for example, the OpenType MATH table) to help with the hierarchical process of equation layout. In particular, they may contain stylistic and stretching glyph variants useful in setting mathematical equations.",
                "type": "value",
                "value": "math"
            },
            {
                "name": "fangsong",
                "prose": "This font family is used for Fang Song (仿宋) typefaces in Chinese. Fang Song is a relaxed, intermediate form between Song (serif) and Kai (cursive). Typically, the horizontal lines are tilted, the endpoint flourishes are smaller, and there is less variation in stroke width, compared to a Song style. Fang Song is often used for official Chinese Government documents.",
                "type": "value",
                "value": "fangsong"
            },
            {
                "name": "ui-serif",
                "prose": "This font family is used for the serif variant of the system’s user interface. The purpose of ui-serif is to allow web content to integrate with the look and feel of the native OS. Sample ui-serif font on macOS Catalina and iOS 13: New York",
                "type": "value",
                "value": "ui-serif"
            },
            {
                "name": "ui-sans-serif",
                "prose": "This font family is used for the sans-serif variant of the system’s user interface. The purpose of ui-sans-serif is to allow web content to integrate with the look and feel of the native OS. Sample ui-sans-serif font on macOS Catalina and iOS 13: San Francisco",
                "type": "value",
                "value": "ui-sans-serif"
            },
            {
                "name": "ui-monospace",
                "prose": "This font family is used for the monospaced variant of the system’s user interface. The purpose of ui-monospace is to allow web content to integrate with the look and feel of the native OS. Sample ui-monospace font on macOS Catalina and iOS 13: SF Mono",
                "type": "value",
                "value": "ui-monospace"
            },
            {
                "name": "ui-rounded",
                "prose": "This font family is used for the rounded variant of the system’s user interface. The purpose of ui-rounded is to allow web content to integrate with the look and feel of the native OS. Sample ui-rounded font on macOS Catalina and iOS 13: SF Rounded",
                "type": "value",
                "value": "ui-rounded"
            }
        ]
    },
    "<font-weight-absolute>": {
        "name": "<font-weight-absolute>",
        "type": "type",
        "value": "[normal | bold | <number [1,1000]>]"
    },
    "<font-variant-css2>": {
        "name": "<font-variant-css2>",
        "type": "type",
        "value": "[normal | small-caps]"
    },
    "<font-stretch-css3>": {
        "name": "<font-stretch-css3>",
        "type": "type",
        "value": "[normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded]"
    },
    "<common-lig-values>": {
        "name": "<common-lig-values>",
        "type": "type",
        "value": "[ common-ligatures | no-common-ligatures ]"
    },
    "<discretionary-lig-values>": {
        "name": "<discretionary-lig-values>",
        "type": "type",
        "value": "[ discretionary-ligatures | no-discretionary-ligatures ]"
    },
    "<historical-lig-values>": {
        "name": "<historical-lig-values>",
        "type": "type",
        "value": "[ historical-ligatures | no-historical-ligatures ]"
    },
    "<contextual-alt-values>": {
        "name": "<contextual-alt-values>",
        "type": "type",
        "value": "[ contextual | no-contextual ]"
    },
    "<numeric-figure-values>": {
        "name": "<numeric-figure-values>",
        "type": "type",
        "value": "[ lining-nums | oldstyle-nums ]"
    },
    "<numeric-spacing-values>": {
        "name": "<numeric-spacing-values>",
        "type": "type",
        "value": "[ proportional-nums | tabular-nums ]"
    },
    "<numeric-fraction-values>": {
        "name": "<numeric-fraction-values>",
        "type": "type",
        "value": "[ diagonal-fractions | stacked-fractions ]"
    },
    "<feature-value-name>": {
        "name": "<feature-value-name>",
        "type": "type",
        "value": "<ident>"
    },
    "<east-asian-variant-values>": {
        "name": "<east-asian-variant-values>",
        "type": "type",
        "value": "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
    },
    "<east-asian-width-values>": {
        "name": "<east-asian-width-values>",
        "type": "type",
        "value": "[ full-width | proportional-width ]"
    },
    "running()": {
        "name": "running()",
        "type": "function",
        "value": "running( <custom-ident> )"
    },
    "nth()": {
        "name": "nth()",
        "type": "function",
        "value": "( An+B [of <custom-ident>]?)"
    },
    "<track-list>": {
        "name": "<track-list>",
        "type": "type",
        "value": "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
    },
    "<auto-track-list>": {
        "name": "<auto-track-list>",
        "type": "type",
        "value": "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat> [ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
    },
    "<explicit-track-list>": {
        "name": "<explicit-track-list>",
        "type": "type",
        "value": "[ <line-names>? <track-size> ]+ <line-names>?"
    },
    "<line-name-list>": {
        "name": "<line-name-list>",
        "type": "type",
        "value": "[ <line-names> | <name-repeat> ]+"
    },
    "<track-size>": {
        "name": "<track-size>",
        "type": "type",
        "value": "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage [0,∞]> )"
    },
    "<fixed-size>": {
        "name": "<fixed-size>",
        "type": "type",
        "value": "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
    },
    "<track-breadth>": {
        "name": "<track-breadth>",
        "type": "type",
        "value": "<length-percentage [0,∞]> | <flex [0,∞]> | min-content | max-content | auto"
    },
    "<inflexible-breadth>": {
        "name": "<inflexible-breadth>",
        "type": "type",
        "value": "<length-percentage [0,∞]> | min-content | max-content | auto"
    },
    "<fixed-breadth>": {
        "name": "<fixed-breadth>",
        "type": "type",
        "value": "<length-percentage [0,∞]>"
    },
    "<line-names>": {
        "name": "<line-names>",
        "type": "type",
        "value": "'[' <custom-ident>* ']'"
    },
    "repeat()": {
        "name": "repeat()",
        "prose": "The repeat() notation represents a repeated fragment of the track list, allowing a large number of columns or rows that exhibit a recurring pattern to be written in a more compact form.",
        "type": "function",
        "values": [
            {
                "name": "auto-fill",
                "prose": "Otherwise on a standalone axis, when auto-fill is given as the repetition number, if the grid container has a definite size or max size in the relevant axis, then the number of repetitions is the largest possible positive integer that does not cause the grid to overflow the content box of its grid container (treating each track as its max track sizing function if that is definite or as its minimum track sizing function otherwise, flooring the max track sizing function by the min track sizing function if both are definite, and taking gap into account); if any number of repetitions would overflow, then 1 repetition. Otherwise, if the grid container has a definite min size in the relevant axis, the number of repetitions is the smallest possible positive integer that fulfills that minimum requirement. Otherwise, the specified track list repeats only once.",
                "type": "value",
                "value": "auto-fill"
            },
            {
                "name": "auto-fit",
                "prose": "The auto-fit keyword behaves the same as auto-fill, except that after grid item placement any empty repeated tracks are collapsed. An empty track is one with no in-flow grid items placed into or spanning across it. (This can result in all tracks being collapsed, if they’re all empty.)",
                "type": "value",
                "value": "auto-fit"
            }
        ]
    },
    "<track-repeat>": {
        "name": "<track-repeat>",
        "type": "type",
        "value": "repeat( [ <integer [1,∞]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
    },
    "<auto-repeat>": {
        "name": "<auto-repeat>",
        "type": "type",
        "value": "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    "<fixed-repeat>": {
        "name": "<fixed-repeat>",
        "type": "type",
        "value": "repeat( [ <integer [1,∞]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
    },
    "<name-repeat>": {
        "name": "<name-repeat>",
        "type": "type",
        "value": "repeat( [ <integer [1,∞]> | auto-fill ], <line-names>+)"
    },
    "<flex>": {
        "name": "<flex>",
        "prose": "A flexible length or <flex> is a dimension with the fr unit, which represents a fraction of the leftover space in the grid container. Tracks sized with fr units are called flexible tracks as they flex in response to leftover space similar to how flex items with a zero base size fill space in a flex container.",
        "type": "type",
        "values": [
            {
                "name": "fr",
                "prose": "A flexible length or <flex> is a dimension with the fr unit, which represents a fraction of the leftover space in the grid container. Tracks sized with fr units are called flexible tracks as they flex in response to leftover space similar to how flex items with a zero base size fill space in a flex container.",
                "type": "value",
                "value": "fr"
            }
        ]
    },
    "<custom-highlight-name>": {
        "name": "<custom-highlight-name>",
        "prose": "The ::highlight(<custom-highlight-name>) pseudo-element (also known as the custom highlight pseudo-element) represents the portion of a document that is being contained or partially contained in all the ranges of the registered custom highlight with the custom highlight name <custom-highlight-name>, if any. <custom-highlight-name> must be a valid CSS <ident-token>.",
        "type": "type"
    },
    "<image>": {
        "name": "<image>",
        "type": "type",
        "value": "<url> | <gradient>"
    },
    "image-set()": {
        "name": "image-set()",
        "prose": "Delivering the most appropriate image resolution for a user’s device can be a difficult task. Ideally, images should be in the same resolution as the device they’re being viewed in, which can vary between users. However, other factors can factor into the decision of which image to send; for example, if the user is on a slow mobile connection, they may prefer to receive lower-res images rather than waiting for a large proper-res image to load. The image-set() function allows an author to ignore most of these issues, simply providing multiple resolutions of an image and letting the UA decide which is most appropriate in a given situation.",
        "type": "function",
        "value": "image-set( <image-set-option># )",
        "values": [
            {
                "name": "type()",
                "value": "type( <string> )",
                "type": "function"
            }
        ]
    },
    "<image-set-option>": {
        "name": "<image-set-option>",
        "type": "type",
        "value": "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
    },
    "image()": {
        "name": "image()",
        "type": "function",
        "value": "image( <image-tags>? [ <image-src>? , <color>? ]! )"
    },
    "<image-tags>": {
        "name": "<image-tags>",
        "type": "type",
        "value": "[ ltr | rtl ]"
    },
    "<image-src>": {
        "name": "<image-src>",
        "type": "type",
        "value": "[ <url> | <string> ]"
    },
    "cross-fade()": {
        "name": "cross-fade()",
        "type": "function",
        "value": "cross-fade( <cf-image># )"
    },
    "<cf-image>": {
        "name": "<cf-image>",
        "type": "type",
        "value": "<percentage [0,100]>? && [ <image> | <color> ]"
    },
    "element()": {
        "name": "element()",
        "type": "function",
        "value": "element( <id-selector> )"
    },
    "<gradient>": {
        "name": "<gradient>",
        "type": "type",
        "value": "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
    },
    "linear-gradient()": {
        "name": "linear-gradient()",
        "prose": "The linear-gradient() notation specifies a linear gradient in CSS. Its syntax is as follows:",
        "type": "function",
        "value": "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
    },
    "<side-or-corner>": {
        "name": "<side-or-corner>",
        "type": "type",
        "value": "[left | right] || [top | bottom]"
    },
    "radial-gradient()": {
        "name": "radial-gradient()",
        "prose": "The radial-gradient() notation specifies a radial gradient by indicating the center of the gradient (where the 0% ellipse will be) and the size and shape of the ending shape (the 100% ellipse). Color stops are given as a list, just as for linear-gradient(). Starting from the gradient center and progressing towards (and potentially beyond) the ending shape, uniformly-scaled concentric ellipses are drawn and colored according to the specified color stops.",
        "type": "function",
        "value": "radial-gradient( [ <rg-ending-shape> || <rg-size> ]? [ at <position> ]? , <color-stop-list> )",
        "values": [
            {
                "name": "<position>",
                "prose": "Determines the center of the gradient. The <position> value type (which is also used for background-position) is defined in [CSS-VALUES-3], and is resolved using the center-point as the object area and the gradient box as the positioning area. If this argument is omitted, it defaults to center.",
                "type": "value",
                "value": "<position>"
            },
            {
                "name": "<rg-ending-shape>",
                "prose": "Can be either circle or ellipse; determines whether the gradient’s ending shape is a circle or an ellipse, respectively. If <rg-ending-shape> is omitted, the ending shape defaults to a circle if the <rg-size> is a single <length>, and to an ellipse otherwise.",
                "type": "value",
                "value": "<rg-ending-shape>"
            },
            {
                "name": "<rg-size>",
                "prose": "Determines the size of the gradient’s ending shape. If omitted it defaults to farthest-corner. It can be given explicitly or by keyword. For the purpose of the keyword definitions, consider the gradient box edges as extending infinitely in both directions, rather than being finite line segments. If the ending-shape is an ellipse, its axises are aligned with the horizontal and vertical axises. Both circle and ellipse gradients accept the following <rg-extent-keyword> values: If <rg-ending-shape> is specified as circle or is omitted, the <rg-size> may be given explicitly as: If <rg-ending-shape> is specified as ellipse or is omitted, <rg-size> may instead be given explicitly as:",
                "type": "value",
                "value": "<rg-size>"
            }
        ]
    },
    "conic-gradient()": {
        "name": "conic-gradient()",
        "type": "function",
        "value": "conic-gradient( [ [ [ from <angle> ]? [ at <position> ]? ] || <color-interpolation-method> ]? , <angular-color-stop-list> )",
        "values": [
            {
                "name": "<angle>",
                "prose": "The entire gradient is rotated by this angle. If omitted, defaults to 0deg. The unit identifier may be omitted if the <angle> is zero.",
                "type": "value",
                "value": "<angle>"
            },
            {
                "name": "<position>",
                "prose": "Determines the gradient center of the gradient. The <position> value type (which is also used for background-position) is defined in [CSS-VALUES-3], and is resolved using the center-point as the object area and the gradient box as the positioning area. If this argument is omitted, it defaults to center.",
                "type": "value",
                "value": "<position>"
            }
        ]
    },
    "repeating-linear-gradient()": {
        "name": "repeating-linear-gradient()",
        "prose": "In addition to linear-gradient() and radial-gradient(), this specification defines repeating-linear-gradient() and repeating-radial-gradient() values. These notations take the same values and are interpreted the same as their respective non-repeating siblings defined previously.",
        "type": "function"
    },
    "repeating-radial-gradient()": {
        "name": "repeating-radial-gradient()",
        "prose": "In addition to linear-gradient() and radial-gradient(), this specification defines repeating-linear-gradient() and repeating-radial-gradient() values. These notations take the same values and are interpreted the same as their respective non-repeating siblings defined previously.",
        "type": "function",
        "values": [
            {
                "name": "<position>",
                "prose": "Determines the center of the gradient. The <position> value type (which is also used for background-position) is defined in [CSS-VALUES-3], and is resolved using the center-point as the object area and the gradient box as the positioning area. If this argument is omitted, it defaults to center.",
                "type": "value",
                "value": "<position>"
            },
            {
                "name": "<rg-ending-shape>",
                "prose": "Can be either circle or ellipse; determines whether the gradient’s ending shape is a circle or an ellipse, respectively. If <rg-ending-shape> is omitted, the ending shape defaults to a circle if the <rg-size> is a single <length>, and to an ellipse otherwise.",
                "type": "value",
                "value": "<rg-ending-shape>"
            },
            {
                "name": "<rg-size>",
                "prose": "Determines the size of the gradient’s ending shape. If omitted it defaults to farthest-corner. It can be given explicitly or by keyword. For the purpose of the keyword definitions, consider the gradient box edges as extending infinitely in both directions, rather than being finite line segments. If the ending-shape is an ellipse, its axises are aligned with the horizontal and vertical axises. Both circle and ellipse gradients accept the following <rg-extent-keyword> values: If <rg-ending-shape> is specified as circle or is omitted, the <rg-size> may be given explicitly as: If <rg-ending-shape> is specified as ellipse or is omitted, <rg-size> may instead be given explicitly as:",
                "type": "value",
                "value": "<rg-size>"
            }
        ]
    },
    "repeating-conic-gradient()": {
        "name": "repeating-conic-gradient()",
        "prose": "In addition to linear-gradient(), radial-gradient(), and conic-gradient(), this specification defines repeating-linear-gradient(), repeating-radial-gradient(), and repeating-conic-gradient() values. These notations take the same values and are interpreted the same as their respective non-repeating siblings defined previously.",
        "type": "function",
        "values": [
            {
                "name": "<angle>",
                "prose": "The entire gradient is rotated by this angle. If omitted, defaults to 0deg. The unit identifier may be omitted if the <angle> is zero.",
                "type": "value",
                "value": "<angle>"
            },
            {
                "name": "<position>",
                "prose": "Determines the gradient center of the gradient. The <position> value type (which is also used for background-position) is defined in [CSS-VALUES-3], and is resolved using the center-point as the object area and the gradient box as the positioning area. If this argument is omitted, it defaults to center.",
                "type": "value",
                "value": "<position>"
            }
        ]
    },
    "<color-stop-list>": {
        "name": "<color-stop-list>",
        "type": "type",
        "value": "<linear-color-stop> , [ <linear-color-hint>? , <linear-color-stop> ]#"
    },
    "<linear-color-stop>": {
        "name": "<linear-color-stop>",
        "type": "type",
        "value": "<color> && <length-percentage>?"
    },
    "<linear-color-hint>": {
        "name": "<linear-color-hint>",
        "type": "type",
        "value": "<length-percentage>"
    },
    "<color-stop-length>": {
        "name": "<color-stop-length>",
        "type": "type",
        "value": "<length-percentage>{1,2}"
    },
    "<angular-color-stop-list>": {
        "name": "<angular-color-stop-list>",
        "type": "type",
        "value": "<angular-color-stop> , [ <angular-color-hint>? , <angular-color-stop> ]#"
    },
    "<angular-color-stop>": {
        "name": "<angular-color-stop>",
        "type": "type",
        "value": "<color> && <color-stop-angle>?"
    },
    "<angular-color-hint>": {
        "name": "<angular-color-hint>",
        "type": "type",
        "value": "<angle-percentage>"
    },
    "<color-stop-angle>": {
        "name": "<color-stop-angle>",
        "type": "type",
        "value": "<angle-percentage>{1,2}"
    },
    "<color-stop>": {
        "name": "<color-stop>",
        "type": "type",
        "value": "<color-stop-length> | <color-stop-angle>"
    },
    "<image-1D>": {
        "name": "<image-1D>",
        "prose": "While <image> values represent a 2-dimensional (2D) image, and <color> can be thought of as a 0-dimensional (0D) image (unvarying in either axis), some contexts require a 1-dimensional (1D) image, which specifies colors along an abstract, directionless, single-axis paint line. The <image-1D> type represents such 1D images, including the stripes() functional notation:",
        "type": "type",
        "value": "<stripes()>"
    },
    "stripes()": {
        "name": "stripes()",
        "prose": "The stripes() function defines a 1D image as a comma-separated list of colored stripes, each placed end-to-end on the paint line in the order given.",
        "type": "function",
        "value": "stripes( <color-stripe># )",
        "values": [
            {
                "name": "<percentage [0,100]>",
                "prose": "Percentage thicknesses are relative to the total width. Only values between 0% and 100% (inclusive) are valid.",
                "type": "value",
                "value": "<percentage [0,100]>"
            },
            {
                "name": "<length [0,∞]>",
                "prose": "Negative length values are invalid.",
                "type": "value",
                "value": "<length [0,∞]>"
            },
            {
                "name": "<flex>",
                "prose": "A <flex> is evaluated as a fraction of the total width relative to the total sum of <flex> entries in the function, after subtracting the thickness of any non-<flex> entries (flooring the subtraction result at zero). If the sum of <flex> values is less than 1fr, the result of the subtraction is multiplied by the sum’s value before being distributed.",
                "type": "value",
                "value": "<flex>"
            }
        ]
    },
    "<color-stripe>": {
        "name": "<color-stripe>",
        "prose": "Each <color-stripe> entry defines a solid-color stripe with the specified <color> and thickness. If the thickness is omitted, it defaults to 1fr. Thickness values are intepreted as follows:",
        "type": "type",
        "value": "<color> && [ <length-percentage> | <flex> ]?"
    },
    "-webkit-image-set()": {
        "name": "-webkit-image-set()",
        "prose": "Implementations must accept -webkit-image-set() as a parse-time alias of image-set(). (It’s a valid value, with identical arguments to image-set(), and is turned into image-set() during parsing.)",
        "type": "function"
    },
    "<rg-size>": {
        "name": "<rg-size>",
        "type": "type",
        "value": "<rg-extent-keyword> | <length [0,∞]> | <length-percentage [0,∞]>{2}",
        "values": [
            {
                "name": "<length [0,∞]>",
                "prose": "Gives the radius of the circle explicitly. Negative values are invalid.",
                "type": "value",
                "value": "<length [0,∞]>"
            },
            {
                "name": "<length-percentage [0,∞]>{2}",
                "prose": "Gives the size of the ellipse explicitly. The first value represents the horizontal radius, the second the vertical radius. Percentages values are relative to the corresponding dimension of the gradient box. Negative values are invalid.",
                "type": "value",
                "value": "<length-percentage [0,∞]>{2}"
            }
        ]
    },
    "<rg-extent-keyword>": {
        "name": "<rg-extent-keyword>",
        "type": "type",
        "value": "closest-corner | closest-side | farthest-corner | farthest-side",
        "values": [
            {
                "name": "closest-side",
                "prose": "The ending shape is sized so that it exactly meets the side of the gradient box closest to the gradient’s center. If the shape is an ellipse, it exactly meets the closest side in each dimension.",
                "type": "value",
                "value": "closest-side"
            },
            {
                "name": "farthest-side",
                "prose": "Same as closest-side, except the ending shape is sized based on the farthest side(s).",
                "type": "value",
                "value": "farthest-side"
            },
            {
                "name": "closest-corner",
                "prose": "The ending shape is sized so that it passes through the corner of the gradient box closest to the gradient’s center. If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.",
                "type": "value",
                "value": "closest-corner"
            },
            {
                "name": "farthest-corner",
                "prose": "Same as closest-corner, except the ending shape is sized based on the farthest corner. If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.",
                "type": "value",
                "value": "farthest-corner"
            }
        ]
    },
    "<rg-ending-shape>": {
        "name": "<rg-ending-shape>",
        "type": "type",
        "value": "circle | ellipse",
        "values": [
            {
                "name": "circle",
                "type": "value",
                "value": "circle"
            },
            {
                "name": "ellipse",
                "type": "value",
                "value": "ellipse"
            }
        ]
    },
    "<link-param>": {
        "name": "<link-param>",
        "type": "type",
        "value": "param( <custom-property-name> <declaration-value>? )"
    },
    "<counter-name>": {
        "name": "<counter-name>",
        "prose": "Counters are referred to in CSS syntax using the <counter-name> type, which represents their name as a <custom-ident>. A <counter-name> name cannot match the keyword none; such an identifier is invalid as a <counter-name>.",
        "type": "type"
    },
    "<reversed-counter-name>": {
        "name": "<reversed-counter-name>",
        "type": "type",
        "value": "reversed( <counter-name> )"
    },
    "<counter>": {
        "name": "<counter>",
        "type": "type",
        "value": "<counter()> | <counters()>"
    },
    "counter()": {
        "name": "counter()",
        "type": "function",
        "value": "counter( <counter-name>, <counter-style>? )",
        "values": [
            {
                "name": "list-item",
                "prose": "In addition to any explicitly defined counters that authors write in their styles, list items automatically increment a special list-item counter, which is used when generating the default marker string on list items (see list-style-type).",
                "type": "value",
                "value": "list-item"
            }
        ]
    },
    "counters()": {
        "name": "counters()",
        "type": "function",
        "value": "counters( <counter-name>, <string>, <counter-style>? )",
        "values": [
            {
                "name": "list-item",
                "prose": "In addition to any explicitly defined counters that authors write in their styles, list items automatically increment a special list-item counter, which is used when generating the default marker string on list items (see list-style-type).",
                "type": "value",
                "value": "list-item"
            }
        ]
    },
    "<clip-source>": {
        "name": "<clip-source>",
        "type": "type",
        "value": "<url>"
    },
    "<geometry-box>": {
        "name": "<geometry-box>",
        "type": "type",
        "value": "<shape-box> | fill-box | stroke-box | view-box"
    },
    "<mask-reference>": {
        "name": "<mask-reference>",
        "type": "type",
        "value": "none | <image> | <mask-source>"
    },
    "<mask-source>": {
        "name": "<mask-source>",
        "type": "type",
        "value": "<url>"
    },
    "<masking-mode>": {
        "name": "<masking-mode>",
        "type": "type",
        "value": "alpha | luminance | match-source"
    },
    "<compositing-operator>": {
        "name": "<compositing-operator>",
        "type": "type",
        "value": "add | subtract | intersect | exclude"
    },
    "<mask-layer>": {
        "name": "<mask-layer>",
        "type": "type",
        "value": "<mask-reference> || <position> [ / <bg-size> ]? ||<repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
    },
    "<namespace-prefix>": {
        "name": "<namespace-prefix>",
        "type": "type",
        "value": "<ident>"
    },
    "<page-selector-list>": {
        "name": "<page-selector-list>",
        "type": "type",
        "value": "<page-selector>#"
    },
    "<page-selector>": {
        "name": "<page-selector>",
        "type": "type",
        "value": "[ <ident-token>? <pseudo-page>* ]!"
    },
    "<pseudo-page>": {
        "name": "<pseudo-page>",
        "type": "type",
        "value": "':' [ left | right | first | blank ]"
    },
    "paint()": {
        "name": "paint()",
        "type": "function",
        "value": "paint( <ident>, <declaration-value>? )"
    },
    "shape()": {
        "name": "shape()",
        "type": "function",
        "value": "shape( <'fill-rule'>? from <coordinate-pair>, <shape-command>#)",
        "values": [
            {
                "name": "<coordinate-pair>",
                "value": "<length-percentage>{2}",
                "type": "type"
            },
            {
                "name": "<by-to>",
                "value": "by | to",
                "type": "type",
                "values": [
                    {
                        "name": "by",
                        "prose": "<by-to> = by | to",
                        "type": "value",
                        "value": "by"
                    },
                    {
                        "name": "to",
                        "prose": "<by-to> = by | to",
                        "type": "value",
                        "value": "to"
                    }
                ]
            },
            {
                "name": "<move-command>",
                "value": "move <by-to> <coordinate-pair>",
                "type": "type"
            },
            {
                "name": "move",
                "prose": "<move-command> = move <by-to> <coordinate-pair>",
                "type": "value",
                "value": "move"
            },
            {
                "name": "<line-command>",
                "value": "line <by-to> <coordinate-pair>",
                "type": "type"
            },
            {
                "name": "line",
                "prose": "<line-command> = line <by-to> <coordinate-pair>",
                "type": "value",
                "value": "line"
            },
            {
                "name": "<hv-line-command>",
                "value": "[hline | vline] <by-to> <length-percentage>",
                "type": "type"
            },
            {
                "name": "hline",
                "prose": "<hv-line-command> = [hline | vline] <by-to> <length-percentage>",
                "type": "value",
                "value": "hline"
            },
            {
                "name": "vline",
                "prose": "<hv-line-command> = [hline | vline] <by-to> <length-percentage>",
                "type": "value",
                "value": "vline"
            },
            {
                "name": "<curve-command>",
                "value": "curve <by-to> <coordinate-pair> via <coordinate-pair>{1,2}",
                "type": "type"
            },
            {
                "name": "curve",
                "prose": "<curve-command> = curve <by-to> <coordinate-pair> via <coordinate-pair>{1,2}",
                "type": "value",
                "value": "curve"
            },
            {
                "name": "<smooth-command>",
                "value": "smooth <by-to> <coordinate-pair> [via <coordinate-pair>]?",
                "type": "type"
            },
            {
                "name": "smooth",
                "prose": "<smooth-command> = smooth <by-to> <coordinate-pair> [via <coordinate-pair>]?",
                "type": "value",
                "value": "smooth"
            },
            {
                "name": "<arc-command>",
                "value": "arc <by-to> <coordinate-pair> of <length-percentage>{1,2} [ <arc-sweep> || <arc-size> || rotate <angle> ]?",
                "type": "type"
            },
            {
                "name": "arc",
                "prose": "<arc-command> = arc <by-to> <coordinate-pair> of <length-percentage>{1,2} [ <arc-sweep> || <arc-size> || rotate <angle> ]",
                "type": "value",
                "value": "arc",
                "values": [
                    {
                        "name": "cw",
                        "prose": "<arc-sweep> can be cw or ccw, indicating that the arc that is traced around the ellipse clockwise or counter-clockwise from the center, respectively, must be chosen. If omitted, this defaults to ccw.",
                        "type": "value",
                        "value": "cw"
                    },
                    {
                        "name": "ccw",
                        "prose": "<arc-sweep> can be cw or ccw, indicating that the arc that is traced around the ellipse clockwise or counter-clockwise from the center, respectively, must be chosen. If omitted, this defaults to ccw.",
                        "type": "value",
                        "value": "ccw"
                    },
                    {
                        "name": "large",
                        "prose": "<arc-size> can be large or small, indicating that the larger or smaller, respectively, of the two possible arcs must be chosen. If omitted, this defaults to small.",
                        "type": "value",
                        "value": "large"
                    },
                    {
                        "name": "small",
                        "prose": "<arc-size> can be large or small, indicating that the larger or smaller, respectively, of the two possible arcs must be chosen. If omitted, this defaults to small.",
                        "type": "value",
                        "value": "small"
                    }
                ]
            },
            {
                "name": "<arc-sweep>",
                "prose": "<arc-sweep> can be cw or ccw, indicating that the arc that is traced around the ellipse clockwise or counter-clockwise from the center, respectively, must be chosen. If omitted, this defaults to ccw.",
                "type": "type",
                "value": "cw | ccw"
            },
            {
                "name": "<arc-size>",
                "prose": "<arc-size> can be large or small, indicating that the larger or smaller, respectively, of the two possible arcs must be chosen. If omitted, this defaults to small.",
                "type": "type",
                "value": "large | small"
            },
            {
                "name": "close",
                "prose": "Adds a closepath command to the list of path data commands.",
                "type": "value",
                "value": "close"
            }
        ]
    },
    "<shape-command>": {
        "name": "<shape-command>",
        "prose": "The sequence of <shape-command>s represent further path data commands. Each command’s starting point is the previous command’s ending point.",
        "type": "type",
        "value": "<move-command> | <line-command> | <hv-line-command> | <curve-command> | <smooth-command> | <arc-command> | close"
    },
    "<basic-shape>": {
        "name": "<basic-shape>",
        "prose": "The <basic-shape> type can be specified using basic shape functions. When using this syntax to define shapes, the reference box is defined by each property that uses <basic-shape> values. The coordinate system for the shape has its origin on the top-left corner of the reference box with the x-axis running to the right and the y-axis running downwards. All the lengths expressed in percentages are resolved from the used dimensions of the reference box.",
        "type": "type",
        "values": [
            {
                "name": "inset()",
                "value": "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )",
                "type": "function"
            },
            {
                "name": "xywh()",
                "value": "xywh( <length-percentage>{2} <length-percentage [0,∞]>{2} [ round <'border-radius'> ]? )",
                "type": "function"
            },
            {
                "name": "rect()",
                "value": "rect( [ <length-percentage> | auto ]{4} [ round <'border-radius'> ]? )",
                "type": "function"
            },
            {
                "name": "circle()",
                "value": "circle( <shape-radius>? [ at <position> ]? )",
                "type": "function"
            },
            {
                "name": "ellipse()",
                "value": "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )",
                "type": "function"
            },
            {
                "name": "polygon()",
                "value": "polygon( <'fill-rule'>? , [<length-percentage> <length-percentage>]# )",
                "type": "function"
            },
            {
                "name": "path()",
                "value": "path( [<'fill-rule'>,]? <string> )",
                "type": "function",
                "values": [
                    {
                        "name": "<string>",
                        "type": "value",
                        "value": "<string>"
                    }
                ]
            }
        ]
    },
    "<shape-radius>": {
        "name": "<shape-radius>",
        "value": "<length-percentage [0,∞]> | closest-side | farthest-side",
        "type": "type"
    },
    "<basic-shape-rect>": {
        "name": "<basic-shape-rect>",
        "type": "type",
        "value": "<inset()> | <rect()> | <xywh()>"
    },
    "<shape-box>": {
        "name": "<shape-box>",
        "type": "type",
        "value": "<box> | margin-box",
        "values": [
            {
                "name": "margin-box",
                "prose": "The margin-box value defines the shape enclosed by the outside margin edge. The corner radii of this shape are determined by the corresponding border-radius and margin values. If the ratio of border-radius/margin is 1 or more, or margin is negative or zero, then the margin box corner radius is max(border-radius + margin, 0). If the ratio of border-radius/margin is less than 1, and margin is positive, then the margin box corner radius is border-radius + margin * (1 + (ratio-1)^3).",
                "type": "value",
                "value": "margin-box"
            },
            {
                "name": "border-box",
                "prose": "The border-box value defines the shape enclosed by the outside border edge. This shape follows all of the normal border radius shaping rules for the outside of the border.",
                "type": "value",
                "value": "border-box"
            },
            {
                "name": "padding-box",
                "prose": "The padding-box value defines the shape enclosed by the outside padding edge. This shape follows all of the normal border radius shaping rules for the inside of the border.",
                "type": "value",
                "value": "padding-box"
            },
            {
                "name": "content-box",
                "prose": "The content-box value defines the shape enclosed by the outside content edge. Each corner radius of this box is the larger of 0 or border-radius - border-width - padding.",
                "type": "value",
                "value": "content-box"
            }
        ]
    },
    "<generic-voice>": {
        "name": "<generic-voice>",
        "value": "[<age>? <gender> <integer>?]",
        "type": "type"
    },
    "<ident-token>": {
        "name": "<ident-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<function-token>": {
        "name": "<function-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<at-keyword-token>": {
        "name": "<at-keyword-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<hash-token>": {
        "name": "<hash-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<string-token>": {
        "name": "<string-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<bad-string-token>": {
        "name": "<bad-string-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<url-token>": {
        "name": "<url-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<bad-url-token>": {
        "name": "<bad-url-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<delim-token>": {
        "name": "<delim-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<number-token>": {
        "name": "<number-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<percentage-token>": {
        "name": "<percentage-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<dimension-token>": {
        "name": "<dimension-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<whitespace-token>": {
        "name": "<whitespace-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<CDO-token>": {
        "name": "<CDO-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<CDC-token>": {
        "name": "<CDC-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<colon-token>": {
        "name": "<colon-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<semicolon-token>": {
        "name": "<semicolon-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<comma-token>": {
        "name": "<comma-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<[-token>": {
        "name": "<[-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<]-token>": {
        "name": "<]-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<(-token>": {
        "name": "<(-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<)-token>": {
        "name": "<)-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<{-token>": {
        "name": "<{-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<}-token>": {
        "name": "<}-token>",
        "prose": "The output of tokenization step is a stream of zero or more of the following tokens: <ident-token>, <function-token>, <at-keyword-token>, <hash-token>, <string-token>, <bad-string-token>, <url-token>, <bad-url-token>, <delim-token>, <number-token>, <percentage-token>, <dimension-token>, <whitespace-token>, <CDO-token>, <CDC-token>, <colon-token>, <semicolon-token>, <comma-token>, <[-token>, <]-token>, <(-token>, <)-token>, <{-token>, and <}-token>.",
        "type": "type"
    },
    "<EOF-token>": {
        "name": "<EOF-token>",
        "prose": "A conceptual token representing the end of the list of tokens. Whenever the list of tokens is empty, the next input token is always an <EOF-token>.",
        "type": "type"
    },
    "<an+b>": {
        "name": "<an+b>",
        "type": "type",
        "value": "odd | even | <integer> | <n-dimension> | '+'? n | -n | <ndashdigit-dimension> | '+'? <ndashdigit-ident> | <dashndashdigit-ident> | <n-dimension> <signed-integer> | '+'? n <signed-integer> | -n <signed-integer> | <ndash-dimension> <signless-integer> | '+'? n- <signless-integer> | -n- <signless-integer> | <n-dimension> ['+' | '-'] <signless-integer> | '+'? n ['+' | '-'] <signless-integer> | -n ['+' | '-'] <signless-integer>"
    },
    "<n-dimension>": {
        "name": "<n-dimension>",
        "type": "type"
    },
    "<ndash-dimension>": {
        "name": "<ndash-dimension>",
        "type": "type"
    },
    "<ndashdigit-dimension>": {
        "name": "<ndashdigit-dimension>",
        "type": "type"
    },
    "<ndashdigit-ident>": {
        "name": "<ndashdigit-ident>",
        "type": "type"
    },
    "<dashndashdigit-ident>": {
        "name": "<dashndashdigit-ident>",
        "type": "type"
    },
    "<signed-integer>": {
        "name": "<signed-integer>",
        "type": "type"
    },
    "<signless-integer>": {
        "name": "<signless-integer>",
        "type": "type"
    },
    "<urange>": {
        "name": "<urange>",
        "prose": "Some constructs, such as the unicode-range descriptor for the @font-face rule, need a way to describe one or more unicode code points. The <urange> production represents a range of one or more unicode code points.",
        "type": "type",
        "value": "u '+' <ident-token> '?'* | u <dimension-token> '?'* | u <number-token> '?'* | u <number-token> <dimension-token> | u <number-token> <number-token> | u '+' '?'+"
    },
    "<style-block>": {
        "name": "<style-block>",
        "prose": "The <style-block> production represents the contents of a style rule’s block. It may only be used in grammars as the sole value in a block, and represents that the contents of the block must be parsed using the consume a style block’s contents algorithm.",
        "type": "type"
    },
    "<declaration-list>": {
        "name": "<declaration-list>",
        "prose": "The <declaration-list> production represents a list of declarations. It may only be used in grammars as the sole value in a block, and represents that the contents of the block must be parsed using the consume a list of declarations algorithm.",
        "type": "type"
    },
    "<rule-list>": {
        "name": "<rule-list>",
        "prose": "Similarly, the <rule-list> production represents a list of rules, and may only be used in grammars as the sole value in a block. It represents that the contents of the block must be parsed using the consume a list of rules algorithm.",
        "type": "type"
    },
    "<stylesheet>": {
        "name": "<stylesheet>",
        "prose": "Finally, the <stylesheet> production represents a list of rules. It is identical to <rule-list>, except that blocks using it default to accepting all rules that aren’t otherwise limited to a particular context.",
        "type": "type"
    },
    "<declaration-value>": {
        "name": "<declaration-value>",
        "prose": "The <declaration-value> production matches any sequence of one or more tokens, so long as the sequence does not contain <bad-string-token>, <bad-url-token>, unmatched <)-token>, <]-token>, or <}-token>, or top-level <semicolon-token> tokens or <delim-token> tokens with a value of \"!\". It represents the entirety of what a valid declaration can have as its value.",
        "type": "type"
    },
    "<any-value>": {
        "name": "<any-value>",
        "prose": "The <any-value> production is identical to <declaration-value>, but also allows top-level <semicolon-token> tokens and <delim-token> tokens with a value of \"!\". It represents the entirety of what valid CSS can be in any context.",
        "type": "type"
    },
    "<autospace>": {
        "name": "<autospace>",
        "type": "type",
        "value": "no-autospace | [ ideograph-alpha || ideograph-numeric || punctuation ] || [ insert | replace ]"
    },
    "<spacing-trim>": {
        "name": "<spacing-trim>",
        "type": "type",
        "value": "space-all | trim-auto | [ allow-end || space-first ]"
    },
    "<transform-function>": {
        "name": "<transform-function>",
        "prose": "The value of the transform property is a list of <transform-function>. The set of allowed transform functions is given below. In the following functions, a <zero> behaves the same as 0deg (\"unitless 0\" angles are preserved for legacy compat). A percentage for horizontal translations is relative to the width of the reference box. A percentage for vertical translations is relative to the height of the reference box.",
        "type": "type"
    },
    "scale()": {
        "name": "scale()",
        "value": "scale( [ <number> | <percentage> ]#{1,2} )",
        "type": "function"
    },
    "scaleX()": {
        "name": "scaleX()",
        "value": "scaleX( [ <number> | <percentage> ] )",
        "type": "function"
    },
    "scaleY()": {
        "name": "scaleY()",
        "value": "scaleY( [ <number> | <percentage> ] )",
        "type": "function"
    },
    "matrix3d()": {
        "name": "matrix3d()",
        "value": "matrix3d( <number>#{16} )",
        "type": "function"
    },
    "translate3d()": {
        "name": "translate3d()",
        "value": "translate3d( <length-percentage> , <length-percentage> , <length> )",
        "type": "function"
    },
    "translateZ()": {
        "name": "translateZ()",
        "value": "translateZ( <length> )",
        "type": "function"
    },
    "scale3d()": {
        "name": "scale3d()",
        "value": "scale3d( [ <number> | <percentage> ]#{3} )",
        "type": "function"
    },
    "scaleZ()": {
        "name": "scaleZ()",
        "value": "scaleZ( [ <number> | <percentage> ] )",
        "type": "function"
    },
    "rotate3d()": {
        "name": "rotate3d()",
        "value": "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )",
        "type": "function"
    },
    "rotateX()": {
        "name": "rotateX()",
        "value": "rotateX( [ <angle> | <zero> ] )",
        "type": "function"
    },
    "rotateY()": {
        "name": "rotateY()",
        "value": "rotateY( [ <angle> | <zero> ] )",
        "type": "function"
    },
    "rotateZ()": {
        "name": "rotateZ()",
        "value": "rotateZ( [ <angle> | <zero> ] )",
        "type": "function"
    },
    "perspective()": {
        "name": "perspective()",
        "value": "perspective( [ <length [0,∞]> | none ] )",
        "type": "function",
        "values": [
            {
                "name": "none",
                "prose": "perspective() = perspective( [ <length [0,∞]> | none ] )",
                "type": "value",
                "value": "none"
            }
        ]
    },
    "<transform-list>": {
        "name": "<transform-list>",
        "type": "type",
        "value": "<transform-function>+"
    },
    "<single-transition-property>": {
        "name": "<single-transition-property>",
        "value": "all | <custom-ident>",
        "type": "type"
    },
    "<single-transition>": {
        "name": "<single-transition>",
        "value": "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>",
        "type": "type"
    },
    "<outline-line-style>": {
        "name": "<outline-line-style>",
        "prose": "<outline-line-style> accepts the same values as <line-style> (CSS Backgrounds 3 § 3.2 Line Patterns: the border-style properties) with the same meaning, except that hidden is not a legal outline style. In addition, the outline-style property accepts the value auto. The auto value permits the user agent to render a custom outline style, typically a style which is either a user interface default for the platform, or perhaps a style that is richer than can be described in detail in CSS, e.g. a rounded edge outline with semi-translucent outer pixels that appears to glow. As such, this specification does not define how the outline-color and outline-width are incorporated or used (if at all) when rendering auto style outlines. User agents may treat auto as solid.",
        "type": "type"
    },
    "<id>": {
        "name": "<id>",
        "prose": "The <id> value is an ID selector [SELECT]. In response to directional navigation input corresponding to the property, the focus is navigated to the first element in tree order matching the selector. If this refers to the currently focused element, the directional navigation input respective to the nav- property is ignored — there is no need to refocus the same element. If no element matches the selector, the user agent automatically determines which element to navigate the focus to. If the focus is navigated to an element that was not otherwise focusable, it becomes focusable only as the result of this directional navigation, and the :focus pseudo-class matches the element while it is focused as such.",
        "type": "type"
    },
    "<target-name>": {
        "name": "<target-name>",
        "prose": "The <target-name> parameter indicates the target frame for the focus navigation. It is a <string> and it MUST NOT start with the underscore \"_\" character. Error handling: if it does start with an underscore, \"_parent\" navigates to the parent frame, \"_root\" is treated as root, and other values navigate to a frame by that name if it exists. If the specified target frame does not exist, the parameter will be treated as the keyword current, which means to simply use the frame that the element is in. The keyword root indicates that the user agent should target the full window.",
        "type": "type"
    },
    "toggle()": {
        "name": "toggle()",
        "prose": "The toggle() expression allows descendant elements to cycle over a list of values instead of inheriting the same value.",
        "type": "function"
    },
    "<toggle-value>": {
        "name": "<toggle-value>",
        "prose": "where <toggle-value> is any CSS value that is valid where the expression is placed. If any of the values inside are not valid, then the entire toggle() expression is invalid. The toggle() expression may be used as the value of any property, but must be the only component in that property’s value.",
        "type": "type"
    },
    "attr()": {
        "name": "attr()",
        "prose": "The attr() function substitutes the value of an attribute on an element into a property, similar to how the var() function substitutes a custom property value into a function.",
        "type": "function",
        "value": "attr( <q-name> <attr-type>? , <declaration-value>?)",
        "values": [
            {
                "name": "string",
                "prose": "The substitution value is a CSS string, whose value is the literal value of the attribute. (No CSS parsing or \"cleanup\" of the value is performed.) No value triggers fallback.",
                "type": "value",
                "value": "string"
            },
            {
                "name": "url",
                "prose": "The substitution value is a CSS <url> value, whose url is the literal value of the attribute. (No CSS parsing or \"cleanup\" of the value is performed.) No value triggers fallback.",
                "type": "value",
                "value": "url"
            },
            {
                "name": "ident",
                "prose": "The substitution value is a CSS <custom-ident>, whose value is the literal value of the attribute, with leading and trailing ASCII whitespace stripped. (No CSS parsing of the value is performed.) If the attribute value, after trimming, is the empty string, there is instead no substitution value. If the <custom-ident>’s value is a CSS-wide keyword or default, there is instead no substitution value.",
                "type": "value",
                "value": "ident"
            },
            {
                "name": "color",
                "prose": "Parse a component value from the attribute’s value. If the result is a <hex-color> or a named color ident, the substitution value is that result as a <color>. Otherwise there is no substitution value.",
                "type": "value",
                "value": "color"
            },
            {
                "name": "number",
                "prose": "Parse a component value from the attribute’s value. If the result is a <number-token>, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "number"
            },
            {
                "name": "percentage",
                "prose": "Parse a component value from the attribute’s value. If the result is a <percentage-token>, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "percentage"
            },
            {
                "name": "length",
                "prose": "Parse a component value from the attribute’s value. If the result is a <dimension-token> whose unit matches the given type, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "length"
            },
            {
                "name": "angle",
                "prose": "Parse a component value from the attribute’s value. If the result is a <dimension-token> whose unit matches the given type, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "angle"
            },
            {
                "name": "time",
                "prose": "Parse a component value from the attribute’s value. If the result is a <dimension-token> whose unit matches the given type, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "time"
            },
            {
                "name": "frequency",
                "prose": "Parse a component value from the attribute’s value. If the result is a <dimension-token> whose unit matches the given type, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "frequency"
            },
            {
                "name": "flex",
                "prose": "Parse a component value from the attribute’s value. If the result is a <dimension-token> whose unit matches the given type, the result is the substitution value. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "flex"
            },
            {
                "name": "<dimension-unit>",
                "prose": "Parse a component value from the attribute’s value. If the result is a <number-token>, the substitution value is a dimension with the result’s value, and the given unit. Otherwise, there is no substitution value.",
                "type": "value",
                "value": "<dimension-unit>"
            }
        ]
    },
    "<attr-type>": {
        "name": "<attr-type>",
        "type": "type",
        "value": "string | url | ident | color | number | percentage | length | angle | time | frequency | flex | <dimension-unit>"
    },
    "<dimension-unit>": {
        "name": "<dimension-unit>",
        "prose": "The <dimension-unit> production matches a literal \"%\" character (that is, a <delim-token> with a value of \"%\") or an ident whose value is any of the CSS units for <length>, <angle>, <time>, <frequency>, or <flex> values (such as px or ms).",
        "type": "type"
    },
    "random()": {
        "name": "random()",
        "prose": "The random() function is a math function that represents a random value between a minimum and maximum value, drawn from a uniform distribution, optionally limiting the possible values to a step between those limits:",
        "type": "function",
        "value": "random( <random-caching-options>? , <calc-sum>, <calc-sum>, [by <calc-sum>]? );"
    },
    "<random-caching-options>": {
        "name": "<random-caching-options>",
        "type": "type",
        "value": "<dashed-ident> || per-element"
    },
    "random-item()": {
        "name": "random-item()",
        "prose": "The random-item() function resolves to a random item from among its list of items.",
        "type": "function",
        "value": "random-item( <random-caching-options> ';' <any-value> [ ';' <any-value> ]* )"
    },
    "mix()": {
        "name": "mix()",
        "prose": "Interpolation of two values can be represented by the mix() functional notation, whose syntax is defined as follows:",
        "type": "function",
        "value": "mix( <percentage> ';' <declaration-value> ';' <declaration-value> )",
        "values": [
            {
                "name": "<percentage>",
                "prose": "Represents the interpolation progress between the two values.",
                "type": "value",
                "value": "<percentage>"
            },
            {
                "name": "<declaration-value>",
                "prose": "The first <declaration-value> represents the value at the “start” (0%) of the interpolation range, interpreted as a value for the property this function is used in. The second <declaration-value> represents the value at the “end” (100%) of the interpolation range, interpreted the same.",
                "type": "value",
                "value": "<declaration-value>"
            }
        ]
    },
    "<ident>": {
        "name": "<ident>",
        "prose": "CSS identifiers, generically denoted by <ident>, consist of a sequence of characters conforming to the <ident-token> grammar. [CSS-SYNTAX-3] Identifiers cannot be quoted; otherwise they would be interpreted as strings. CSS properties accept two classes of identifiers: pre-defined keywords and author-defined identifiers.",
        "type": "type"
    },
    "<custom-ident>": {
        "name": "<custom-ident>",
        "prose": "Some properties accept arbitrary author-defined identifiers as a component value. This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier that would not be misinterpreted as a pre-defined keyword in that property’s value definition. Such identifiers are fully case-sensitive (meaning they’re compared using the \"identical to\" operation), even in the ASCII range (e.g. example and EXAMPLE are two different, unrelated user-defined identifiers).",
        "type": "type"
    },
    "<dashed-ident>": {
        "name": "<dashed-ident>",
        "prose": "The <dashed-ident> production is a <custom-ident>, with all the case-sensitivity that implies, with the additional restriction that it must start with two dashes (U+002D HYPHEN-MINUS).",
        "type": "type"
    },
    "<string>": {
        "name": "<string>",
        "prose": "Strings are denoted by <string>. When written literally, they consist of a sequence of characters delimited by double quotes or single quotes, corresponding to the <string-token> production in the CSS Syntax Module [CSS-SYNTAX-3].",
        "type": "type"
    },
    "url()": {
        "name": "url()",
        "prose": "The <url> type, written with the url() and src() functions, represents a URL, which is a pointer to a resource.",
        "type": "function",
        "value": "url( <string> <url-modifier>* ) | <url-token>"
    },
    "src()": {
        "name": "src()",
        "prose": "The <url> type, written with the url() and src() functions, represents a URL, which is a pointer to a resource.",
        "type": "function",
        "value": "src( <string> <url-modifier>* )"
    },
    "<url>": {
        "name": "<url>",
        "type": "type",
        "value": "<url()> | <src()>"
    },
    "<url-modifier>": {
        "name": "<url-modifier>",
        "prose": "<url>s support specifying additional <url-modifier>s, which change the meaning or the interpretation of the URL somehow. A <url-modifier> is either an <ident> or a functional notation.",
        "type": "type"
    },
    "<request-url-modifier>": {
        "name": "<request-url-modifier>",
        "prose": "The <request-url-modifier>s represent <url-modifier>s that affect the resource’s request. Each <request-url-modifier> has a request modifier steps which accepts a request.",
        "type": "type",
        "value": "<crossorigin-modifier> | <integrity-modifier> | <referrerpolicy-modifier>",
        "values": [
            {
                "name": "<crossorigin-modifier>",
                "value": "crossorigin(anonymous | use-credentials)",
                "type": "type"
            },
            {
                "name": "crossorigin()",
                "prose": "<crossorigin-modifier> = crossorigin(anonymous | use-credentials)",
                "type": "function"
            },
            {
                "name": "anonymous",
                "prose": "<crossorigin-modifier> = crossorigin(anonymous | use-credentials)",
                "type": "value",
                "value": "anonymous"
            },
            {
                "name": "use-credentials",
                "prose": "<crossorigin-modifier> = crossorigin(anonymous | use-credentials)",
                "type": "value",
                "value": "use-credentials"
            },
            {
                "name": "<integrity-modifier>",
                "value": "integrity(<string>)",
                "type": "type"
            },
            {
                "name": "integrity()",
                "prose": "<integrity-modifier> = integrity(<string>)",
                "type": "function"
            },
            {
                "name": "<referrerpolicy-modifier>",
                "value": "referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "type"
            },
            {
                "name": "referrerpolicy()",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "function"
            },
            {
                "name": "no-referrer",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "no-referrer"
            },
            {
                "name": "no-referrer-when-downgrade",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "no-referrer-when-downgrade"
            },
            {
                "name": "same-origin",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "same-origin"
            },
            {
                "name": "origin",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "origin"
            },
            {
                "name": "strict-origin",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "strict-origin"
            },
            {
                "name": "origin-when-cross-origin",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "origin-when-cross-origin"
            },
            {
                "name": "strict-origin-when-cross-origin",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "strict-origin-when-cross-origin"
            },
            {
                "name": "unsafe-url",
                "prose": "<referrerpolicy-modifier> = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)",
                "type": "value",
                "value": "unsafe-url"
            }
        ]
    },
    "<integer>": {
        "name": "<integer>",
        "prose": "Integer values are denoted by <integer>.",
        "type": "type"
    },
    "<number>": {
        "name": "<number>",
        "prose": "Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.",
        "type": "type"
    },
    "<zero>": {
        "name": "<zero>",
        "prose": "The value <zero> represents a literal number with the value 0. Expressions that merely evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>; only literal <number-token>s do.",
        "type": "type"
    },
    "<dimension>": {
        "name": "<dimension>",
        "prose": "The general term dimension refers to a number with a unit attached to it; and is denoted by <dimension>.",
        "type": "type"
    },
    "<percentage>": {
        "name": "<percentage>",
        "prose": "Percentage values are denoted by <percentage>, and indicates a value that is some fraction of another reference value.",
        "type": "type"
    },
    "<length-percentage>": {
        "name": "<length-percentage>",
        "value": "[ <length> | <percentage> ]",
        "type": "type"
    },
    "<frequency-percentage>": {
        "name": "<frequency-percentage>",
        "value": "[ <frequency> | <percentage> ]",
        "type": "type"
    },
    "<angle-percentage>": {
        "name": "<angle-percentage>",
        "value": "[ <angle> | <percentage> ]",
        "type": "type"
    },
    "<time-percentage>": {
        "name": "<time-percentage>",
        "value": "[ <time> | <percentage> ]",
        "type": "type"
    },
    "<ratio>": {
        "name": "<ratio>",
        "prose": "Ratio values are denoted by <ratio>, and represent the ratio of two numeric values. It most often represents an aspect ratio, relating a width (first) to a height (second).",
        "type": "type",
        "value": "<number [0,∞]> [ / <number [0,∞]> ]?"
    },
    "<length>": {
        "name": "<length>",
        "prose": "Lengths refer to distance measurements and are denoted by <length> in the property definitions. A length is a dimension.",
        "type": "type",
        "values": [
            {
                "name": "em",
                "prose": "Equal to the computed value of the font-size property of the element on which it is used. The rule: h1 { line-height: 1.2em } means that the line height of h1 elements will be 20% greater than the font size of h1 element. On the other hand: h1 { font-size: 1.2em } means that the font size of h1 elements will be 20% greater than the computed font size inherited by h1 elements.",
                "type": "value",
                "value": "em"
            },
            {
                "name": "rem",
                "prose": "Equal to the computed value of the em unit on the root element.",
                "type": "value",
                "value": "rem"
            },
            {
                "name": "ex",
                "prose": "Equal to the used x-height of the first available font [CSS3-FONTS]. The x-height is so called because it is often equal to the height of the lowercase \"x\". However, an ex is defined even for fonts that do not contain an \"x\". The x-height of a font can be found in different ways. Some fonts contain reliable metrics for the x-height. If reliable font metrics are not available, UAs may determine the x-height from the height of a lowercase glyph. One possible heuristic is to look at how far the glyph for the lowercase \"o\" extends below the baseline, and subtract that value from the top of its bounding box. In the cases where it is impossible or impractical to determine the x-height, a value of 0.5em must be assumed.",
                "type": "value",
                "value": "ex"
            },
            {
                "name": "rex",
                "prose": "Equal to the value of the ex unit on the root element.",
                "type": "value",
                "value": "rex"
            },
            {
                "name": "cap",
                "prose": "Equal to the used cap-height of the first available font [CSS3-FONTS]. The cap-height is so called because it is approximately equal to the height of a capital Latin letter. However, a cap is defined even for fonts that do not contain Latin letters. The cap-height of a font can be found in different ways. Some fonts contain reliable metrics for the cap-height. If reliable font metrics are not available, UAs may determine the cap-height from the height of an uppercase glyph. One possible heuristic is to look at how far the glyph for the uppercase “O” extends below the baseline, and subtract that value from the top of its bounding box. In the cases where it is impossible or impractical to determine the cap-height, the font’s ascent must be used.",
                "type": "value",
                "value": "cap"
            },
            {
                "name": "rcap",
                "prose": "Equal to the value of the cap unit on the root element.",
                "type": "value",
                "value": "rcap"
            },
            {
                "name": "ch",
                "prose": "Represents the typical advance measure of European alphanumeric characters, and measured as the used advance measure of the “0” (ZERO, U+0030) glyph in the font used to render it. (The advance measure of a glyph is its advance width or height, whichever is in the inline axis of the element.) In the cases where it is impossible or impractical to determine the measure of the “0” glyph, it must be assumed to be 0.5em wide by 1em tall. Thus, the ch unit falls back to 0.5em in the general case, and to 1em when it would be typeset upright (i.e. writing-mode is vertical-rl or vertical-lr and text-orientation is upright).",
                "type": "value",
                "value": "ch"
            },
            {
                "name": "rch",
                "prose": "Equal to the value of the ch unit on the root element.",
                "type": "value",
                "value": "rch"
            },
            {
                "name": "ic",
                "prose": "Represents the typical advance measure of CJK letters, and measured as the used advance measure of the “水” (CJK water ideograph, U+6C34) glyph found in the font used to render it. In the cases where it is impossible or impractical to determine the ideographic advance measure, it must be assumed to be 1em.",
                "type": "value",
                "value": "ic"
            },
            {
                "name": "ric",
                "prose": "Equal to the value of the ic unit on the root element.",
                "type": "value",
                "value": "ric"
            },
            {
                "name": "lh",
                "prose": "Equal to the computed value of the line-height property of the element on which it is used, converting normal to an absolute length by using only the metrics of the first available font.",
                "type": "value",
                "value": "lh"
            },
            {
                "name": "rlh",
                "prose": "Equal to the value of the lh unit on the root element.",
                "type": "value",
                "value": "rlh"
            },
            {
                "name": "vw",
                "prose": "Equal to 1% of the width of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively. In the example below, if the width of the viewport is 200mm, the font size of h1 elements will be 16mm (i.e. (8×200mm)/100). h1 { font-size: 8vw }",
                "type": "value",
                "value": "vw"
            },
            {
                "name": "svw",
                "prose": "Equal to 1% of the width of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively. In the example below, if the width of the viewport is 200mm, the font size of h1 elements will be 16mm (i.e. (8×200mm)/100). h1 { font-size: 8vw }",
                "type": "value",
                "value": "svw"
            },
            {
                "name": "lvw",
                "prose": "Equal to 1% of the width of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively. In the example below, if the width of the viewport is 200mm, the font size of h1 elements will be 16mm (i.e. (8×200mm)/100). h1 { font-size: 8vw }",
                "type": "value",
                "value": "lvw"
            },
            {
                "name": "dvw",
                "prose": "Equal to 1% of the width of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively. In the example below, if the width of the viewport is 200mm, the font size of h1 elements will be 16mm (i.e. (8×200mm)/100). h1 { font-size: 8vw }",
                "type": "value",
                "value": "dvw"
            },
            {
                "name": "vh",
                "prose": "Equal to 1% of the height of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively.",
                "type": "value",
                "value": "vh"
            },
            {
                "name": "svh",
                "prose": "Equal to 1% of the height of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively.",
                "type": "value",
                "value": "svh"
            },
            {
                "name": "lvh",
                "prose": "Equal to 1% of the height of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively.",
                "type": "value",
                "value": "lvh"
            },
            {
                "name": "dvh",
                "prose": "Equal to 1% of the height of the UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size, respectively.",
                "type": "value",
                "value": "dvh"
            },
            {
                "name": "vi",
                "prose": "Equal to 1% of the size of the large viewport size, small viewport size, and dynamic viewport size (respectively) in the box’s inline axis.",
                "type": "value",
                "value": "vi"
            },
            {
                "name": "svi",
                "prose": "Equal to 1% of the size of the large viewport size, small viewport size, and dynamic viewport size (respectively) in the box’s inline axis.",
                "type": "value",
                "value": "svi"
            },
            {
                "name": "lvi",
                "prose": "Equal to 1% of the size of the large viewport size, small viewport size, and dynamic viewport size (respectively) in the box’s inline axis.",
                "type": "value",
                "value": "lvi"
            },
            {
                "name": "dvi",
                "prose": "Equal to 1% of the size of the large viewport size, small viewport size, and dynamic viewport size (respectively) in the box’s inline axis.",
                "type": "value",
                "value": "dvi"
            },
            {
                "name": "vb",
                "prose": "Equal to 1% of the size of the initial containing block UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size (respectively) in the box’s block axis.",
                "type": "value",
                "value": "vb"
            },
            {
                "name": "svb",
                "prose": "Equal to 1% of the size of the initial containing block UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size (respectively) in the box’s block axis.",
                "type": "value",
                "value": "svb"
            },
            {
                "name": "lvb",
                "prose": "Equal to 1% of the size of the initial containing block UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size (respectively) in the box’s block axis.",
                "type": "value",
                "value": "lvb"
            },
            {
                "name": "dvb",
                "prose": "Equal to 1% of the size of the initial containing block UA-default viewport size, small viewport size, large viewport size, and dynamic viewport size (respectively) in the box’s block axis.",
                "type": "value",
                "value": "dvb"
            },
            {
                "name": "vmin",
                "prose": "Equal to the smaller of *vw or *vh.",
                "type": "value",
                "value": "vmin"
            },
            {
                "name": "svmin",
                "prose": "Equal to the smaller of *vw or *vh.",
                "type": "value",
                "value": "svmin"
            },
            {
                "name": "lvmin",
                "prose": "Equal to the smaller of *vw or *vh.",
                "type": "value",
                "value": "lvmin"
            },
            {
                "name": "dvmin",
                "prose": "Equal to the smaller of *vw or *vh.",
                "type": "value",
                "value": "dvmin"
            },
            {
                "name": "vmax",
                "prose": "Equal to the larger of *vw or *vh.",
                "type": "value",
                "value": "vmax"
            },
            {
                "name": "svmax",
                "prose": "Equal to the larger of *vw or *vh.",
                "type": "value",
                "value": "svmax"
            },
            {
                "name": "lvmax",
                "prose": "Equal to the larger of *vw or *vh.",
                "type": "value",
                "value": "lvmax"
            },
            {
                "name": "dvmax",
                "prose": "Equal to the larger of *vw or *vh.",
                "type": "value",
                "value": "dvmax"
            },
            {
                "name": "cm",
                "type": "value",
                "value": "cm"
            },
            {
                "name": "mm",
                "type": "value",
                "value": "mm"
            },
            {
                "name": "Q",
                "type": "value",
                "value": "Q"
            },
            {
                "name": "in",
                "type": "value",
                "value": "in"
            },
            {
                "name": "pc",
                "type": "value",
                "value": "pc"
            },
            {
                "name": "pt",
                "type": "value",
                "value": "pt"
            },
            {
                "name": "px",
                "type": "value",
                "value": "px"
            }
        ]
    },
    "<angle>": {
        "name": "<angle>",
        "prose": "Angle values are <dimension>s denoted by <angle>. The angle unit identifiers are:",
        "type": "type",
        "values": [
            {
                "name": "deg",
                "prose": "Degrees. There are 360 degrees in a full circle.",
                "type": "value",
                "value": "deg"
            },
            {
                "name": "grad",
                "prose": "Gradians, also known as \"gons\" or \"grades\". There are 400 gradians in a full circle.",
                "type": "value",
                "value": "grad"
            },
            {
                "name": "rad",
                "prose": "Radians. There are 2π radians in a full circle.",
                "type": "value",
                "value": "rad"
            },
            {
                "name": "turn",
                "prose": "Turns. There is 1 turn in a full circle.",
                "type": "value",
                "value": "turn"
            }
        ]
    },
    "<time>": {
        "name": "<time>",
        "prose": "Time values are dimensions denoted by <time>. The time unit identifiers are:",
        "type": "type",
        "values": [
            {
                "name": "s",
                "prose": "Seconds.",
                "type": "value",
                "value": "s"
            },
            {
                "name": "ms",
                "prose": "Milliseconds. There are 1000 milliseconds in a second.",
                "type": "value",
                "value": "ms"
            }
        ]
    },
    "<frequency>": {
        "name": "<frequency>",
        "prose": "Frequency values are dimensions denoted by <frequency>. The frequency unit identifiers are:",
        "type": "type",
        "values": [
            {
                "name": "Hz",
                "prose": "Hertz. It represents the number of occurrences per second.",
                "type": "value",
                "value": "Hz"
            },
            {
                "name": "kHz",
                "prose": "KiloHertz. A kiloHertz is 1000 Hertz.",
                "type": "value",
                "value": "kHz"
            }
        ]
    },
    "<resolution>": {
        "name": "<resolution>",
        "prose": "Resolution units are dimensions denoted by <resolution>. The resolution unit identifiers are:",
        "type": "type",
        "values": [
            {
                "name": "dpi",
                "prose": "Dots per inch.",
                "type": "value",
                "value": "dpi"
            },
            {
                "name": "dpcm",
                "prose": "Dots per centimeter.",
                "type": "value",
                "value": "dpcm"
            },
            {
                "name": "dppx",
                "prose": "Dots per px unit.",
                "type": "value",
                "value": "dppx"
            },
            {
                "name": "x",
                "prose": "Dots per px unit.",
                "type": "value",
                "value": "x"
            }
        ]
    },
    "<position>": {
        "name": "<position>",
        "prose": "The <position> value specifies the position of a object area (e.g. background image) inside a positioning area (e.g. background positioning area). It is interpreted as specified for background-position. [CSS3-BACKGROUND]",
        "type": "type",
        "value": "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
    },
    "calc()": {
        "name": "calc()",
        "prose": "The calc() function is a math function that allows basic arithmetic to be performed on numerical values, using addition (+), subtraction (-), multiplication (*), division (/), and parentheses.",
        "type": "function",
        "value": "calc( <calc-sum> )",
        "values": [
            {
                "name": "e",
                "prose": "e is the base of the natural logarithm, approximately equal to 2.7182818284590452354.",
                "type": "value",
                "value": "e"
            },
            {
                "name": "pi",
                "prose": "pi is the ratio of a circle’s circumference to its diameter, approximately equal to 3.1415926535897932.",
                "type": "value",
                "value": "pi"
            },
            {
                "name": "infinity",
                "prose": "When a calculation or a subtree of a calculation becomes infinite or NaN, representing it with a numeric value is no longer possible. To aid in serialization of these degenerate values, the additional math constants infinity (with the value +∞), -infinity (with the value −∞), and NaN (with the value NaN) are defined.",
                "type": "value",
                "value": "infinity"
            },
            {
                "name": "-infinity",
                "prose": "When a calculation or a subtree of a calculation becomes infinite or NaN, representing it with a numeric value is no longer possible. To aid in serialization of these degenerate values, the additional math constants infinity (with the value +∞), -infinity (with the value −∞), and NaN (with the value NaN) are defined.",
                "type": "value",
                "value": "-infinity"
            },
            {
                "name": "NaN",
                "prose": "When a calculation or a subtree of a calculation becomes infinite or NaN, representing it with a numeric value is no longer possible. To aid in serialization of these degenerate values, the additional math constants infinity (with the value +∞), -infinity (with the value −∞), and NaN (with the value NaN) are defined.",
                "type": "value",
                "value": "NaN"
            }
        ]
    },
    "min()": {
        "name": "min()",
        "prose": "The min() or max() functions contain one or more comma-separated calculations, and represent the smallest (most negative) or largest (most positive) of them, respectively.",
        "type": "function",
        "value": "min( <calc-sum># )"
    },
    "max()": {
        "name": "max()",
        "prose": "The min() or max() functions contain one or more comma-separated calculations, and represent the smallest (most negative) or largest (most positive) of them, respectively.",
        "type": "function",
        "value": "max( <calc-sum># )"
    },
    "clamp()": {
        "name": "clamp()",
        "prose": "The clamp() function takes three calculations—a minimum value, a central value, and a maximum value—and represents its central calculation, clamped according to its min and max calculations, favoring the min calculation if it conflicts with the max. (That is, given clamp(MIN, VAL, MAX), it represents exactly the same value as max(MIN, min(VAL, MAX))).",
        "type": "function",
        "value": "clamp( <calc-sum>#{3} )"
    },
    "round()": {
        "name": "round()",
        "value": "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )",
        "type": "function"
    },
    "<rounding-strategy>": {
        "name": "<rounding-strategy>",
        "prose": "If A is exactly equal to an integer multiple of B, round() resolves to A exactly (preserving whether A is 0⁻ or 0⁺, if relevant). Otherwise, there are two integer multiples of B that are potentially \"closest\" to A, lower B which is closer to −∞ and upper B which is closer to +∞. The following <rounding-strategy>s dictate how to choose between them:",
        "type": "type",
        "value": "nearest | up | down | to-zero",
        "values": [
            {
                "name": "nearest",
                "prose": "Choose whichever of lower B and upper B that has the smallest absolute difference from A. If both have an equal difference (A is exactly between the two values), choose upper B.",
                "type": "value",
                "value": "nearest"
            },
            {
                "name": "up",
                "prose": "Choose upper B.",
                "type": "value",
                "value": "up"
            },
            {
                "name": "down",
                "prose": "Choose lower B.",
                "type": "value",
                "value": "down"
            },
            {
                "name": "to-zero",
                "prose": "Choose whichever of lower B and upper B that has the smallest absolute difference from 0.",
                "type": "value",
                "value": "to-zero"
            }
        ]
    },
    "mod()": {
        "name": "mod()",
        "value": "mod( <calc-sum>, <calc-sum> )",
        "type": "function"
    },
    "rem()": {
        "name": "rem()",
        "value": "rem( <calc-sum>, <calc-sum> )",
        "type": "function"
    },
    "sin()": {
        "name": "sin()",
        "value": "sin( <calc-sum> )",
        "type": "function"
    },
    "cos()": {
        "name": "cos()",
        "value": "cos( <calc-sum> )",
        "type": "function"
    },
    "tan()": {
        "name": "tan()",
        "value": "tan( <calc-sum> )",
        "type": "function"
    },
    "asin()": {
        "name": "asin()",
        "value": "asin( <calc-sum> )",
        "type": "function"
    },
    "acos()": {
        "name": "acos()",
        "value": "acos( <calc-sum> )",
        "type": "function"
    },
    "atan()": {
        "name": "atan()",
        "value": "atan( <calc-sum> )",
        "type": "function"
    },
    "atan2()": {
        "name": "atan2()",
        "value": "atan2( <calc-sum>, <calc-sum> )",
        "type": "function"
    },
    "pow()": {
        "name": "pow()",
        "value": "pow( <calc-sum>, <calc-sum> )",
        "type": "function"
    },
    "sqrt()": {
        "name": "sqrt()",
        "value": "sqrt( <calc-sum> )",
        "type": "function"
    },
    "hypot()": {
        "name": "hypot()",
        "value": "hypot( <calc-sum># )",
        "type": "function"
    },
    "log()": {
        "name": "log()",
        "value": "log( <calc-sum>, <calc-sum>? )",
        "type": "function"
    },
    "exp()": {
        "name": "exp()",
        "value": "exp( <calc-sum> )",
        "type": "function"
    },
    "abs()": {
        "name": "abs()",
        "value": "abs( <calc-sum> )",
        "type": "function"
    },
    "sign()": {
        "name": "sign()",
        "value": "sign( <calc-sum> )",
        "type": "function"
    },
    "<calc-sum>": {
        "name": "<calc-sum>",
        "type": "type",
        "value": "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
    },
    "<calc-product>": {
        "name": "<calc-product>",
        "type": "type",
        "value": "<calc-value> [ [ '*' | '/' ] <calc-value> ]*"
    },
    "<calc-value>": {
        "name": "<calc-value>",
        "type": "type",
        "value": "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
    },
    "<calc-constant>": {
        "name": "<calc-constant>",
        "type": "type",
        "value": "e | pi | infinity | -infinity | NaN"
    },
    "<quirky-length>": {
        "name": "<quirky-length>",
        "prose": "When CSS is being parsed in quirks mode, <quirky-length> is a type of <length> that is only valid in certain properties:",
        "type": "type"
    },
    "<custom-property-name>": {
        "name": "<custom-property-name>",
        "prose": "A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo. The <custom-property-name> production corresponds to this: it’s defined as any <dashed-ident> (a valid identifier that starts with two dashes), except -- itself, which is reserved for future use by CSS. Custom properties are solely for use by authors and users; CSS will never give them a meaning beyond what is presented here.",
        "type": "type"
    },
    "var()": {
        "name": "var()",
        "type": "function",
        "value": "var( <custom-property-name> , <declaration-value>? )"
    },
    "<pt-name-selector>": {
        "name": "<pt-name-selector>",
        "type": "type",
        "value": "'*' | <custom-ident>"
    },
    "<animateable-feature>": {
        "name": "<animateable-feature>",
        "type": "type",
        "value": "scroll-position | contents | <custom-ident>"
    },
    "<paint>": {
        "name": "<paint>",
        "type": "type",
        "value": "none | <image> | <svg-paint>",
        "values": [
            {
                "name": "none",
                "prose": "Indicates no paint is applied.",
                "type": "value",
                "value": "none"
            }
        ]
    },
    "<svg-paint>": {
        "name": "<svg-paint>",
        "type": "type",
        "value": "child | child( <integer> )",
        "values": [
            {
                "name": "child",
                "prose": "Refers to the last child paint server element of the element being painted. If there is no such child, behaves as none.",
                "type": "value",
                "value": "child"
            },
            {
                "name": "child()",
                "value": "child()",
                "type": "value"
            }
        ]
    },
    "<filter-value-list>": {
        "name": "<filter-value-list>",
        "type": "type",
        "value": "[ <filter-function> | <url> ]+"
    },
    "<filter-function>": {
        "name": "<filter-function>",
        "type": "type",
        "value": "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <sepia()> | <saturate()>"
    },
    "<number-optional-number>": {
        "name": "<number-optional-number>",
        "value": "<number> <number>?",
        "type": "type"
    },
    "filter()": {
        "name": "filter()",
        "type": "function",
        "value": "filter( [ <image> | <string> ], <filter-value-list> )"
    },
    "<source-size-list>": {
        "name": "<source-size-list>",
        "type": "type",
        "value": "<source-size>#? , <source-size-value>"
    },
    "<source-size>": {
        "name": "<source-size>",
        "type": "type",
        "value": "<media-condition> <source-size-value>"
    },
    "<source-size-value>": {
        "name": "<source-size-value>",
        "type": "type",
        "value": "<length>"
    },
    "<media-query-list>": {
        "name": "<media-query-list>",
        "prose": "To parse a <media-query-list> production, parse a comma-separated list of component values, then parse each entry in the returned list as a <media-query>. Its value is the list of <media-query>s so produced.",
        "type": "type"
    },
    "<media-query>": {
        "name": "<media-query>",
        "type": "type",
        "value": "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
    },
    "<media-type>": {
        "name": "<media-type>",
        "type": "type",
        "value": "<ident>"
    },
    "<media-condition>": {
        "name": "<media-condition>",
        "type": "type",
        "value": "<media-not> | <media-in-parens> [ <media-and>* | <media-or>* ]"
    },
    "<media-condition-without-or>": {
        "name": "<media-condition-without-or>",
        "type": "type",
        "value": "<media-not> | <media-in-parens> <media-and>*"
    },
    "<media-not>": {
        "name": "<media-not>",
        "type": "type",
        "value": "not <media-in-parens>"
    },
    "<media-and>": {
        "name": "<media-and>",
        "type": "type",
        "value": "and <media-in-parens>"
    },
    "<media-or>": {
        "name": "<media-or>",
        "type": "type",
        "value": "or <media-in-parens>"
    },
    "<media-in-parens>": {
        "name": "<media-in-parens>",
        "type": "type",
        "value": "( <media-condition> ) | ( <media-feature> ) | <general-enclosed>"
    },
    "<media-feature>": {
        "name": "<media-feature>",
        "type": "type",
        "value": "[ <mf-plain> | <mf-boolean> | <mf-range> ]"
    },
    "<mf-plain>": {
        "name": "<mf-plain>",
        "type": "type",
        "value": "<mf-name> : <mf-value>"
    },
    "<mf-boolean>": {
        "name": "<mf-boolean>",
        "type": "type",
        "value": "<mf-name>"
    },
    "<mf-range>": {
        "name": "<mf-range>",
        "type": "type",
        "value": "<mf-name> <mf-comparison> <mf-value> | <mf-value> <mf-comparison> <mf-name> | <mf-value> <mf-lt> <mf-name> <mf-lt> <mf-value> | <mf-value> <mf-gt> <mf-name> <mf-gt> <mf-value>"
    },
    "<mf-name>": {
        "name": "<mf-name>",
        "type": "type",
        "value": "<ident>"
    },
    "<mf-value>": {
        "name": "<mf-value>",
        "type": "type",
        "value": "<number> | <dimension> | <ident> | <ratio>"
    },
    "<mf-lt>": {
        "name": "<mf-lt>",
        "type": "type",
        "value": "'<' '='?"
    },
    "<mf-gt>": {
        "name": "<mf-gt>",
        "type": "type",
        "value": "'>' '='?"
    },
    "<mf-eq>": {
        "name": "<mf-eq>",
        "type": "type",
        "value": "'='"
    },
    "<mf-comparison>": {
        "name": "<mf-comparison>",
        "type": "type",
        "value": "<mf-lt> | <mf-gt> | <mf-eq>"
    },
    "<general-enclosed>": {
        "name": "<general-enclosed>",
        "type": "type",
        "value": "[ <function-token> <any-value>? ) ] | [ ( <any-value>? ) ]"
    },
    "<mq-boolean>": {
        "name": "<mq-boolean>",
        "type": "type",
        "value": "<integer [0,1]>"
    },
    "<offset-path>": {
        "name": "<offset-path>",
        "type": "type",
        "value": "<ray()> | <url> | <basic-shape>"
    },
    "ray()": {
        "name": "ray()",
        "type": "function",
        "value": "ray( <angle> && <ray-size>? && contain? )",
        "values": [
            {
                "name": "<angle>",
                "prose": "The offset path is a single line segment that starts from the offset starting position and proceeds in the direction defined by the specified <angle>. (Its length is determined by the other arguments.) As with gradient functions, <angle> values are interpreted as bearing angles, with 0deg pointing up and positive angles representing clockwise rotation.",
                "type": "value",
                "value": "<angle>"
            },
            {
                "name": "<ray-size>",
                "prose": "Specifies the length of the offset path (the distance between the offset-distance: 0% and offset-distance: 100% points) relative to the containing box. If no <ray-size> is specified it defaults to closest-side. Individual keywords are:",
                "type": "value",
                "value": "<ray-size>"
            },
            {
                "name": "contain",
                "prose": "The length of the offset path is reduced so that the element stays within the containing block even at offset-distance: 100%. Specifically, the path’s length is reduced by half the width or half the height of the element’s border box, whichever is larger, and floored at zero.",
                "type": "value",
                "value": "contain"
            }
        ]
    },
    "<ray-size>": {
        "name": "<ray-size>",
        "type": "type",
        "value": "closest-side | closest-corner | farthest-side | farthest-corner | sides",
        "values": [
            {
                "name": "closest-side",
                "prose": "The distance from the ray’s starting point to whichever side of the containing block is closest.",
                "type": "value",
                "value": "closest-side"
            },
            {
                "name": "closest-corner",
                "prose": "The distance from the ray’s starting point to whichever corner of the containing block is closest.",
                "type": "value",
                "value": "closest-corner"
            },
            {
                "name": "farthest-side",
                "prose": "The distance from the ray’s starting point to whichever side of the containing block is farthest.",
                "type": "value",
                "value": "farthest-side"
            },
            {
                "name": "farthest-corner",
                "prose": "The distance from the ray’s starting point to whichever corner of the containing block is farthest.",
                "type": "value",
                "value": "farthest-corner"
            },
            {
                "name": "sides",
                "prose": "The distance from the ray’s starting point to the point where the offset path intersects the containing block’s boundary. If the ray’s starting point is on the containing block’s boundary, or outside its bounds entirely, the distance is zero.",
                "type": "value",
                "value": "sides"
            }
        ]
    },
    "scroll()": {
        "name": "scroll()",
        "prose": "The scroll() functional notation can be used as a <single-animation-timeline> value in animation-timeline and specifies a scroll progress timeline. Its syntax is",
        "type": "function",
        "value": "scroll( [ <scroller> || <axis> ]? )",
        "values": [
            {
                "name": "block",
                "prose": "Specifies to use the measure of progress along the block axis of the scroll container. (Default.)",
                "type": "value",
                "value": "block"
            },
            {
                "name": "inline",
                "prose": "Specifies to use the measure of progress along the inline axis of the scroll container.",
                "type": "value",
                "value": "inline"
            },
            {
                "name": "vertical",
                "prose": "Specifies to use the measure of progress along the vertical axis of the scroll container.",
                "type": "value",
                "value": "vertical"
            },
            {
                "name": "horizontal",
                "prose": "Specifies to use the measure of progress along the horizontal axis of the scroll container.",
                "type": "value",
                "value": "horizontal"
            },
            {
                "name": "nearest",
                "prose": "Specifies to use the nearest ancestor scroll container. (Default.)",
                "type": "value",
                "value": "nearest"
            },
            {
                "name": "root",
                "prose": "Specifies to use the document viewport as the scroll container.",
                "type": "value",
                "value": "root"
            },
            {
                "name": "self",
                "prose": "Specifies to use the element’s own principal box as the scroll container. If the principal box is not a scroll container, then the scroll progress timeline is inactive.",
                "type": "value",
                "value": "self"
            }
        ]
    },
    "<axis>": {
        "name": "<axis>",
        "type": "type",
        "value": "block | inline | vertical | horizontal"
    },
    "<scroller>": {
        "name": "<scroller>",
        "type": "type",
        "value": "root | nearest | self"
    },
    "view()": {
        "name": "view()",
        "prose": "The view() functional notation can be used as a <single-animation-timeline> value in animation-timeline and specifies a view progress timeline in reference to the nearest ancestor scroll container. Its syntax is",
        "type": "function",
        "value": "view( [ <axis> || <'view-timeline-inset'> ]? )"
    },
    "<timeline-range-name>": {
        "name": "<timeline-range-name>",
        "prose": "A named timeline range is a named segment of an animation timeline. The start of the segment is represented as 0% progress through the range; the end of the segment is represented as 100% progress through the range. Multiple named timeline ranges can be attached to a given timeline, and multiple such ranges can overlap. For example, the contain range of a view progress timeline overlaps with its cover range. Named timeline ranges are represented by the <timeline-range-name> value type, which indicates a CSS identifier representing one of the predefined named timeline ranges.",
        "type": "type"
    },
    "<selector-list>": {
        "name": "<selector-list>",
        "type": "type",
        "value": "<complex-selector-list>"
    },
    "<complex-selector-list>": {
        "name": "<complex-selector-list>",
        "type": "type",
        "value": "<complex-selector>#"
    },
    "<complex-real-selector-list>": {
        "name": "<complex-real-selector-list>",
        "type": "type",
        "value": "<complex-real-selector>#"
    },
    "<compound-selector-list>": {
        "name": "<compound-selector-list>",
        "type": "type",
        "value": "<compound-selector>#"
    },
    "<simple-selector-list>": {
        "name": "<simple-selector-list>",
        "type": "type",
        "value": "<simple-selector>#"
    },
    "<relative-selector-list>": {
        "name": "<relative-selector-list>",
        "type": "type",
        "value": "<relative-selector>#"
    },
    "<relative-real-selector-list>": {
        "name": "<relative-real-selector-list>",
        "type": "type",
        "value": "<relative-real-selector>#"
    },
    "<complex-selector>": {
        "name": "<complex-selector>",
        "type": "type",
        "value": "<complex-selector-unit> [ <combinator>? <complex-selector-unit> ]*"
    },
    "<complex-selector-unit>": {
        "name": "<complex-selector-unit>",
        "type": "type",
        "value": "[ <compound-selector>? <pseudo-compound-selector>* ]!"
    },
    "<complex-real-selector>": {
        "name": "<complex-real-selector>",
        "type": "type",
        "value": "<compound-selector> [ <combinator>? <compound-selector> ]*"
    },
    "<relative-selector>": {
        "name": "<relative-selector>",
        "type": "type",
        "value": "<combinator>? <complex-selector>"
    },
    "<relative-real-selector>": {
        "name": "<relative-real-selector>",
        "type": "type",
        "value": "<combinator>? <complex-real-selector>"
    },
    "<compound-selector>": {
        "name": "<compound-selector>",
        "type": "type",
        "value": "[ <type-selector>? <subclass-selector>* ]!"
    },
    "<pseudo-compound-selector>": {
        "name": "<pseudo-compound-selector>",
        "type": "type",
        "value": "<pseudo-element-selector> <pseudo-class-selector>*"
    },
    "<simple-selector>": {
        "name": "<simple-selector>",
        "type": "type",
        "value": "<type-selector> | <subclass-selector>"
    },
    "<combinator>": {
        "name": "<combinator>",
        "type": "type",
        "value": "'>' | '+' | '~' | [ '|' '|' ]"
    },
    "<wq-name>": {
        "name": "<wq-name>",
        "type": "type",
        "value": "<ns-prefix>? <ident-token>"
    },
    "<ns-prefix>": {
        "name": "<ns-prefix>",
        "type": "type",
        "value": "[ <ident-token> | '*' ]? '|'"
    },
    "<type-selector>": {
        "name": "<type-selector>",
        "type": "type",
        "value": "<wq-name> | <ns-prefix>? '*'"
    },
    "<subclass-selector>": {
        "name": "<subclass-selector>",
        "type": "type",
        "value": "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
    },
    "<id-selector>": {
        "name": "<id-selector>",
        "type": "type",
        "value": "<hash-token>"
    },
    "<class-selector>": {
        "name": "<class-selector>",
        "type": "type",
        "value": "'.' <ident-token>"
    },
    "<attribute-selector>": {
        "name": "<attribute-selector>",
        "type": "type",
        "value": "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
    },
    "<attr-matcher>": {
        "name": "<attr-matcher>",
        "type": "type",
        "value": "[ '~' | '|' | '^' | '$' | '*' ]? '='"
    },
    "<attr-modifier>": {
        "name": "<attr-modifier>",
        "type": "type",
        "value": "i | s"
    },
    "<pseudo-class-selector>": {
        "name": "<pseudo-class-selector>",
        "type": "type",
        "value": "':' <ident-token> | ':' <function-token> <any-value> ')'"
    },
    "<pseudo-element-selector>": {
        "name": "<pseudo-element-selector>",
        "type": "type",
        "value": "':' <pseudo-class-selector> | <legacy-pseudo-element-selector>"
    },
    "<legacy-pseudo-element-selector>": {
        "name": "<legacy-pseudo-element-selector>",
        "type": "type",
        "value": "':' [before | after | first-line | first-letter]"
    },
    "<forgiving-selector-list>": {
        "name": "<forgiving-selector-list>",
        "prose": "The <forgiving-selector-list> production instead parses each selector in the list individually, simply ignoring ones that fail to parse, so the remaining selectors can still be used.",
        "type": "type"
    }
}
